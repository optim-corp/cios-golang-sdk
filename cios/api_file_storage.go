/*
 * Cios Openapi
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.1
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cios

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// FileStorageApiService FileStorageApi service
type FileStorageApiService service

type ApiCopyNodeRequest struct {
	Ctx _context.Context
	ApiService *FileStorageApiService
	P_bucketId string
	P_nodeId string
	P_bucketEditBody *BucketEditBody
}

func (r ApiCopyNodeRequest) BucketEditBody(bucketEditBody BucketEditBody) ApiCopyNodeRequest {
	r.P_bucketEditBody = &bucketEditBody
	return r
}

func (r ApiCopyNodeRequest) Execute() (SingleNode, *_nethttp.Response, error) {
	return r.ApiService.CopyNodeExecute(r)
}

/*
 * CopyNode Method for CopyNode
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param bucketId
 * @param nodeId
 * @return ApiCopyNodeRequest
 */
func (a *FileStorageApiService) CopyNode(Ctx _context.Context, bucketId string, nodeId string) ApiCopyNodeRequest {
	return ApiCopyNodeRequest{
		ApiService: a,
		Ctx: Ctx,
		P_bucketId: bucketId,
		P_nodeId: nodeId,
	}
}

/*
 * Execute executes the request
 * @return SingleNode
 */
func (a *FileStorageApiService) CopyNodeExecute(r ApiCopyNodeRequest) (SingleNode, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SingleNode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "FileStorageApiService.CopyNode")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/file_storage/buckets/{bucket_id}/nodes/{node_id}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", _neturl.PathEscape(parameterToString(r.P_bucketId, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", _neturl.PathEscape(parameterToString(r.P_nodeId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_bucketEditBody == nil {
		return localVarReturnValue, nil, reportError("bucketEditBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_bucketEditBody
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBucketRequest struct {
	Ctx _context.Context
	ApiService *FileStorageApiService
	P_bucketRequest *BucketRequest
}

func (r ApiCreateBucketRequest) BucketRequest(bucketRequest BucketRequest) ApiCreateBucketRequest {
	r.P_bucketRequest = &bucketRequest
	return r
}

func (r ApiCreateBucketRequest) Execute() (SingleBucket, *_nethttp.Response, error) {
	return r.ApiService.CreateBucketExecute(r)
}

/*
 * CreateBucket Method for CreateBucket
 * file_storage.write
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateBucketRequest
 */
func (a *FileStorageApiService) CreateBucket(Ctx _context.Context) ApiCreateBucketRequest {
	return ApiCreateBucketRequest{
		ApiService: a,
		Ctx: Ctx,
	}
}

/*
 * Execute executes the request
 * @return SingleBucket
 */
func (a *FileStorageApiService) CreateBucketExecute(r ApiCreateBucketRequest) (SingleBucket, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SingleBucket
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "FileStorageApiService.CreateBucket")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/file_storage/buckets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_bucketRequest == nil {
		return localVarReturnValue, nil, reportError("bucketRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_bucketRequest
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDirectoryRequest struct {
	Ctx _context.Context
	ApiService *FileStorageApiService
	P_bucketId string
	P_nodeRequest *NodeRequest
}

func (r ApiCreateDirectoryRequest) NodeRequest(nodeRequest NodeRequest) ApiCreateDirectoryRequest {
	r.P_nodeRequest = &nodeRequest
	return r
}

func (r ApiCreateDirectoryRequest) Execute() (SingleNode, *_nethttp.Response, error) {
	return r.ApiService.CreateDirectoryExecute(r)
}

/*
 * CreateDirectory Method for CreateDirectory
 * file_storage.write
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param bucketId
 * @return ApiCreateDirectoryRequest
 */
func (a *FileStorageApiService) CreateDirectory(Ctx _context.Context, bucketId string) ApiCreateDirectoryRequest {
	return ApiCreateDirectoryRequest{
		ApiService: a,
		Ctx: Ctx,
		P_bucketId: bucketId,
	}
}

/*
 * Execute executes the request
 * @return SingleNode
 */
func (a *FileStorageApiService) CreateDirectoryExecute(r ApiCreateDirectoryRequest) (SingleNode, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SingleNode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "FileStorageApiService.CreateDirectory")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/file_storage/buckets/{bucket_id}/create_directory"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", _neturl.PathEscape(parameterToString(r.P_bucketId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_nodeRequest == nil {
		return localVarReturnValue, nil, reportError("nodeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_nodeRequest
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBucketRequest struct {
	Ctx _context.Context
	ApiService *FileStorageApiService
	P_bucketId string
}


func (r ApiDeleteBucketRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteBucketExecute(r)
}

/*
 * DeleteBucket Method for DeleteBucket
 * file_storage.write
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param bucketId
 * @return ApiDeleteBucketRequest
 */
func (a *FileStorageApiService) DeleteBucket(Ctx _context.Context, bucketId string) ApiDeleteBucketRequest {
	return ApiDeleteBucketRequest{
		ApiService: a,
		Ctx: Ctx,
		P_bucketId: bucketId,
	}
}

/*
 * Execute executes the request
 */
func (a *FileStorageApiService) DeleteBucketExecute(r ApiDeleteBucketRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "FileStorageApiService.DeleteBucket")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/file_storage/buckets/{bucket_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", _neturl.PathEscape(parameterToString(r.P_bucketId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteNodeRequest struct {
	Ctx _context.Context
	ApiService *FileStorageApiService
	P_bucketId string
	P_nodeId string
	P_directorySize *bool
}

func (r ApiDeleteNodeRequest) DirectorySize(directorySize bool) ApiDeleteNodeRequest {
	r.P_directorySize = &directorySize
	return r
}

func (r ApiDeleteNodeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteNodeExecute(r)
}

/*
 * DeleteNode Method for DeleteNode
 * file_storage.write
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param bucketId
 * @param nodeId
 * @return ApiDeleteNodeRequest
 */
func (a *FileStorageApiService) DeleteNode(Ctx _context.Context, bucketId string, nodeId string) ApiDeleteNodeRequest {
	return ApiDeleteNodeRequest{
		ApiService: a,
		Ctx: Ctx,
		P_bucketId: bucketId,
		P_nodeId: nodeId,
	}
}

/*
 * Execute executes the request
 */
func (a *FileStorageApiService) DeleteNodeExecute(r ApiDeleteNodeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "FileStorageApiService.DeleteNode")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/file_storage/buckets/{bucket_id}/nodes/{node_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", _neturl.PathEscape(parameterToString(r.P_bucketId, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", _neturl.PathEscape(parameterToString(r.P_nodeId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.P_directorySize != nil {
		localVarQueryParams.Add("directory_size", parameterToString(*r.P_directorySize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDownloadFileRequest struct {
	Ctx _context.Context
	ApiService *FileStorageApiService
	P_bucketId string
	P_nodeId *string
	P_key *string
}

func (r ApiDownloadFileRequest) NodeId(nodeId string) ApiDownloadFileRequest {
	r.P_nodeId = &nodeId
	return r
}
func (r ApiDownloadFileRequest) Key(key string) ApiDownloadFileRequest {
	r.P_key = &key
	return r
}

func (r ApiDownloadFileRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.DownloadFileExecute(r)
}

/*
 * DownloadFile Method for DownloadFile
 * file_storage.download
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param bucketId
 * @return ApiDownloadFileRequest
 */
func (a *FileStorageApiService) DownloadFile(Ctx _context.Context, bucketId string) ApiDownloadFileRequest {
	return ApiDownloadFileRequest{
		ApiService: a,
		Ctx: Ctx,
		P_bucketId: bucketId,
	}
}

/*
 * Execute executes the request
 * @return string
 */
func (a *FileStorageApiService) DownloadFileExecute(r ApiDownloadFileRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "FileStorageApiService.DownloadFile")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/file_storage/buckets/{bucket_id}/download"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", _neturl.PathEscape(parameterToString(r.P_bucketId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.P_nodeId != nil {
		localVarQueryParams.Add("node_id", parameterToString(*r.P_nodeId, ""))
	}
	if r.P_key != nil {
		localVarQueryParams.Add("key", parameterToString(*r.P_key, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"/_*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBucketRequest struct {
	Ctx _context.Context
	ApiService *FileStorageApiService
	P_bucketId string
}


func (r ApiGetBucketRequest) Execute() (SingleBucket, *_nethttp.Response, error) {
	return r.ApiService.GetBucketExecute(r)
}

/*
 * GetBucket Method for GetBucket
 * file_storage.read
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param bucketId
 * @return ApiGetBucketRequest
 */
func (a *FileStorageApiService) GetBucket(Ctx _context.Context, bucketId string) ApiGetBucketRequest {
	return ApiGetBucketRequest{
		ApiService: a,
		Ctx: Ctx,
		P_bucketId: bucketId,
	}
}

/*
 * Execute executes the request
 * @return SingleBucket
 */
func (a *FileStorageApiService) GetBucketExecute(r ApiGetBucketRequest) (SingleBucket, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SingleBucket
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "FileStorageApiService.GetBucket")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/file_storage/buckets/{bucket_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", _neturl.PathEscape(parameterToString(r.P_bucketId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBucketsRequest struct {
	Ctx _context.Context
	ApiService *FileStorageApiService
	P_limit *int64
	P_offset *int64
	P_order *string
	P_orderBy *string
	P_resourceOwnerId *string
	P_name *string
}

func (r ApiGetBucketsRequest) Limit(limit int64) ApiGetBucketsRequest {
	r.P_limit = &limit
	return r
}
func (r ApiGetBucketsRequest) Offset(offset int64) ApiGetBucketsRequest {
	r.P_offset = &offset
	return r
}
func (r ApiGetBucketsRequest) Order(order string) ApiGetBucketsRequest {
	r.P_order = &order
	return r
}
func (r ApiGetBucketsRequest) OrderBy(orderBy string) ApiGetBucketsRequest {
	r.P_orderBy = &orderBy
	return r
}
func (r ApiGetBucketsRequest) ResourceOwnerId(resourceOwnerId string) ApiGetBucketsRequest {
	r.P_resourceOwnerId = &resourceOwnerId
	return r
}
func (r ApiGetBucketsRequest) Name(name string) ApiGetBucketsRequest {
	r.P_name = &name
	return r
}

func (r ApiGetBucketsRequest) Execute() (MultipleBucket, *_nethttp.Response, error) {
	return r.ApiService.GetBucketsExecute(r)
}

/*
 * GetBuckets Method for GetBuckets
 * file_storage.read
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetBucketsRequest
 */
func (a *FileStorageApiService) GetBuckets(Ctx _context.Context) ApiGetBucketsRequest {
	return ApiGetBucketsRequest{
		ApiService: a,
		Ctx: Ctx,
	}
}

/*
 * Execute executes the request
 * @return MultipleBucket
 */
func (a *FileStorageApiService) GetBucketsExecute(r ApiGetBucketsRequest) (MultipleBucket, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MultipleBucket
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "FileStorageApiService.GetBuckets")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/file_storage/buckets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.P_limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.P_limit, ""))
	}
	if r.P_offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.P_offset, ""))
	}
	if r.P_order != nil {
		localVarQueryParams.Add("order", parameterToString(*r.P_order, ""))
	}
	if r.P_orderBy != nil {
		localVarQueryParams.Add("order_by", parameterToString(*r.P_orderBy, ""))
	}
	if r.P_resourceOwnerId != nil {
		localVarQueryParams.Add("resource_owner_id", parameterToString(*r.P_resourceOwnerId, ""))
	}
	if r.P_name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.P_name, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNodeRequest struct {
	Ctx _context.Context
	ApiService *FileStorageApiService
	P_bucketId string
	P_nodeId string
	P_directorySize *bool
}

func (r ApiGetNodeRequest) DirectorySize(directorySize bool) ApiGetNodeRequest {
	r.P_directorySize = &directorySize
	return r
}

func (r ApiGetNodeRequest) Execute() (SingleNode, *_nethttp.Response, error) {
	return r.ApiService.GetNodeExecute(r)
}

/*
 * GetNode Method for GetNode
 * file_storage.read
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param bucketId
 * @param nodeId
 * @return ApiGetNodeRequest
 */
func (a *FileStorageApiService) GetNode(Ctx _context.Context, bucketId string, nodeId string) ApiGetNodeRequest {
	return ApiGetNodeRequest{
		ApiService: a,
		Ctx: Ctx,
		P_bucketId: bucketId,
		P_nodeId: nodeId,
	}
}

/*
 * Execute executes the request
 * @return SingleNode
 */
func (a *FileStorageApiService) GetNodeExecute(r ApiGetNodeRequest) (SingleNode, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SingleNode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "FileStorageApiService.GetNode")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/file_storage/buckets/{bucket_id}/nodes/{node_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", _neturl.PathEscape(parameterToString(r.P_bucketId, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", _neturl.PathEscape(parameterToString(r.P_nodeId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.P_directorySize != nil {
		localVarQueryParams.Add("directory_size", parameterToString(*r.P_directorySize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNodesRequest struct {
	Ctx _context.Context
	ApiService *FileStorageApiService
	P_bucketId string
	P_parentNodeId *string
	P_recursive *bool
	P_name *string
	P_key *string
	P_isDirectory *bool
	P_limit *int64
	P_offset *int64
	P_orderBy *string
	P_order *string
}

func (r ApiGetNodesRequest) ParentNodeId(parentNodeId string) ApiGetNodesRequest {
	r.P_parentNodeId = &parentNodeId
	return r
}
func (r ApiGetNodesRequest) Recursive(recursive bool) ApiGetNodesRequest {
	r.P_recursive = &recursive
	return r
}
func (r ApiGetNodesRequest) Name(name string) ApiGetNodesRequest {
	r.P_name = &name
	return r
}
func (r ApiGetNodesRequest) Key(key string) ApiGetNodesRequest {
	r.P_key = &key
	return r
}
func (r ApiGetNodesRequest) IsDirectory(isDirectory bool) ApiGetNodesRequest {
	r.P_isDirectory = &isDirectory
	return r
}
func (r ApiGetNodesRequest) Limit(limit int64) ApiGetNodesRequest {
	r.P_limit = &limit
	return r
}
func (r ApiGetNodesRequest) Offset(offset int64) ApiGetNodesRequest {
	r.P_offset = &offset
	return r
}
func (r ApiGetNodesRequest) OrderBy(orderBy string) ApiGetNodesRequest {
	r.P_orderBy = &orderBy
	return r
}
func (r ApiGetNodesRequest) Order(order string) ApiGetNodesRequest {
	r.P_order = &order
	return r
}

func (r ApiGetNodesRequest) Execute() (MultipleNode, *_nethttp.Response, error) {
	return r.ApiService.GetNodesExecute(r)
}

/*
 * GetNodes Method for GetNodes
 * file_storage.read
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param bucketId
 * @return ApiGetNodesRequest
 */
func (a *FileStorageApiService) GetNodes(Ctx _context.Context, bucketId string) ApiGetNodesRequest {
	return ApiGetNodesRequest{
		ApiService: a,
		Ctx: Ctx,
		P_bucketId: bucketId,
	}
}

/*
 * Execute executes the request
 * @return MultipleNode
 */
func (a *FileStorageApiService) GetNodesExecute(r ApiGetNodesRequest) (MultipleNode, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MultipleNode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "FileStorageApiService.GetNodes")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/file_storage/buckets/{bucket_id}/nodes"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", _neturl.PathEscape(parameterToString(r.P_bucketId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.P_parentNodeId != nil {
		localVarQueryParams.Add("parent_node_id", parameterToString(*r.P_parentNodeId, ""))
	}
	if r.P_recursive != nil {
		localVarQueryParams.Add("recursive", parameterToString(*r.P_recursive, ""))
	}
	if r.P_name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.P_name, ""))
	}
	if r.P_key != nil {
		localVarQueryParams.Add("key", parameterToString(*r.P_key, ""))
	}
	if r.P_isDirectory != nil {
		localVarQueryParams.Add("is_directory", parameterToString(*r.P_isDirectory, ""))
	}
	if r.P_limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.P_limit, ""))
	}
	if r.P_offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.P_offset, ""))
	}
	if r.P_orderBy != nil {
		localVarQueryParams.Add("order_by", parameterToString(*r.P_orderBy, ""))
	}
	if r.P_order != nil {
		localVarQueryParams.Add("order", parameterToString(*r.P_order, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoveNodeRequest struct {
	Ctx _context.Context
	ApiService *FileStorageApiService
	P_bucketId string
	P_nodeId string
	P_bucketEditBody *BucketEditBody
}

func (r ApiMoveNodeRequest) BucketEditBody(bucketEditBody BucketEditBody) ApiMoveNodeRequest {
	r.P_bucketEditBody = &bucketEditBody
	return r
}

func (r ApiMoveNodeRequest) Execute() (SingleNode, *_nethttp.Response, error) {
	return r.ApiService.MoveNodeExecute(r)
}

/*
 * MoveNode Method for MoveNode
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param bucketId
 * @param nodeId
 * @return ApiMoveNodeRequest
 */
func (a *FileStorageApiService) MoveNode(Ctx _context.Context, bucketId string, nodeId string) ApiMoveNodeRequest {
	return ApiMoveNodeRequest{
		ApiService: a,
		Ctx: Ctx,
		P_bucketId: bucketId,
		P_nodeId: nodeId,
	}
}

/*
 * Execute executes the request
 * @return SingleNode
 */
func (a *FileStorageApiService) MoveNodeExecute(r ApiMoveNodeRequest) (SingleNode, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SingleNode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "FileStorageApiService.MoveNode")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/file_storage/buckets/{bucket_id}/nodes/{node_id}/move"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", _neturl.PathEscape(parameterToString(r.P_bucketId, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", _neturl.PathEscape(parameterToString(r.P_nodeId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_bucketEditBody == nil {
		return localVarReturnValue, nil, reportError("bucketEditBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_bucketEditBody
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRenameNodeRequest struct {
	Ctx _context.Context
	ApiService *FileStorageApiService
	P_bucketId string
	P_nodeId string
	P_bucketName *BucketName
}

func (r ApiRenameNodeRequest) BucketName(bucketName BucketName) ApiRenameNodeRequest {
	r.P_bucketName = &bucketName
	return r
}

func (r ApiRenameNodeRequest) Execute() (SingleNode, *_nethttp.Response, error) {
	return r.ApiService.RenameNodeExecute(r)
}

/*
 * RenameNode Method for RenameNode
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param bucketId
 * @param nodeId
 * @return ApiRenameNodeRequest
 */
func (a *FileStorageApiService) RenameNode(Ctx _context.Context, bucketId string, nodeId string) ApiRenameNodeRequest {
	return ApiRenameNodeRequest{
		ApiService: a,
		Ctx: Ctx,
		P_bucketId: bucketId,
		P_nodeId: nodeId,
	}
}

/*
 * Execute executes the request
 * @return SingleNode
 */
func (a *FileStorageApiService) RenameNodeExecute(r ApiRenameNodeRequest) (SingleNode, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SingleNode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "FileStorageApiService.RenameNode")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/file_storage/buckets/{bucket_id}/nodes/{node_id}/rename"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", _neturl.PathEscape(parameterToString(r.P_bucketId, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", _neturl.PathEscape(parameterToString(r.P_nodeId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_bucketName == nil {
		return localVarReturnValue, nil, reportError("bucketName is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_bucketName
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateBucketRequest struct {
	Ctx _context.Context
	ApiService *FileStorageApiService
	P_bucketId string
	P_bucketName *BucketName
}

func (r ApiUpdateBucketRequest) BucketName(bucketName BucketName) ApiUpdateBucketRequest {
	r.P_bucketName = &bucketName
	return r
}

func (r ApiUpdateBucketRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateBucketExecute(r)
}

/*
 * UpdateBucket Method for UpdateBucket
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param bucketId
 * @return ApiUpdateBucketRequest
 */
func (a *FileStorageApiService) UpdateBucket(Ctx _context.Context, bucketId string) ApiUpdateBucketRequest {
	return ApiUpdateBucketRequest{
		ApiService: a,
		Ctx: Ctx,
		P_bucketId: bucketId,
	}
}

/*
 * Execute executes the request
 */
func (a *FileStorageApiService) UpdateBucketExecute(r ApiUpdateBucketRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "FileStorageApiService.UpdateBucket")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/file_storage/buckets/{bucket_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", _neturl.PathEscape(parameterToString(r.P_bucketId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_bucketName == nil {
		return nil, reportError("bucketName is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_bucketName
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUploadFileRequest struct {
	Ctx _context.Context
	ApiService *FileStorageApiService
	P_bucketId string
	P_checksum *string
	P_body *string
	P_name *string
	P_nodeId *string
	P_key *string
	P_parentNodeId *string
	P_parentKey *string
	P_force *bool
}

func (r ApiUploadFileRequest) Checksum(checksum string) ApiUploadFileRequest {
	r.P_checksum = &checksum
	return r
}
func (r ApiUploadFileRequest) Body(body string) ApiUploadFileRequest {
	r.P_body = &body
	return r
}
func (r ApiUploadFileRequest) Name(name string) ApiUploadFileRequest {
	r.P_name = &name
	return r
}
func (r ApiUploadFileRequest) NodeId(nodeId string) ApiUploadFileRequest {
	r.P_nodeId = &nodeId
	return r
}
func (r ApiUploadFileRequest) Key(key string) ApiUploadFileRequest {
	r.P_key = &key
	return r
}
func (r ApiUploadFileRequest) ParentNodeId(parentNodeId string) ApiUploadFileRequest {
	r.P_parentNodeId = &parentNodeId
	return r
}
func (r ApiUploadFileRequest) ParentKey(parentKey string) ApiUploadFileRequest {
	r.P_parentKey = &parentKey
	return r
}
func (r ApiUploadFileRequest) Force(force bool) ApiUploadFileRequest {
	r.P_force = &force
	return r
}

func (r ApiUploadFileRequest) Execute() (SingleBucket, *_nethttp.Response, error) {
	return r.ApiService.UploadFileExecute(r)
}

/*
 * UploadFile Method for UploadFile
 * file_storage.upload
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param bucketId
 * @return ApiUploadFileRequest
 */
func (a *FileStorageApiService) UploadFile(Ctx _context.Context, bucketId string) ApiUploadFileRequest {
	return ApiUploadFileRequest{
		ApiService: a,
		Ctx: Ctx,
		P_bucketId: bucketId,
	}
}

/*
 * Execute executes the request
 * @return SingleBucket
 */
func (a *FileStorageApiService) UploadFileExecute(r ApiUploadFileRequest) (SingleBucket, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SingleBucket
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "FileStorageApiService.UploadFile")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/file_storage/buckets/{bucket_id}/upload"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", _neturl.PathEscape(parameterToString(r.P_bucketId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_checksum == nil {
		return localVarReturnValue, nil, reportError("checksum is required and must be specified")
	}
	if r.P_body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	localVarQueryParams.Add("checksum", parameterToString(*r.P_checksum, ""))
	if r.P_name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.P_name, ""))
	}
	if r.P_nodeId != nil {
		localVarQueryParams.Add("node_id", parameterToString(*r.P_nodeId, ""))
	}
	if r.P_key != nil {
		localVarQueryParams.Add("key", parameterToString(*r.P_key, ""))
	}
	if r.P_parentNodeId != nil {
		localVarQueryParams.Add("parent_node_id", parameterToString(*r.P_parentNodeId, ""))
	}
	if r.P_parentKey != nil {
		localVarQueryParams.Add("parent_key", parameterToString(*r.P_parentKey, ""))
	}
	if r.P_force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.P_force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_body
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
