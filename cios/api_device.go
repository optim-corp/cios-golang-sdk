/*
 * Cios Openapi
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.1
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cios

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// DeviceApiService DeviceApi service
type DeviceApiService service

type ApiCreateDeviceRequest struct {
	Ctx _context.Context
	ApiService *DeviceApiService
	P_deviceInfo *DeviceInfo
}

func (r ApiCreateDeviceRequest) DeviceInfo(deviceInfo DeviceInfo) ApiCreateDeviceRequest {
	r.P_deviceInfo = &deviceInfo
	return r
}

func (r ApiCreateDeviceRequest) Execute() (SingleDevice, *_nethttp.Response, error) {
	return r.ApiService.CreateDeviceExecute(r)
}

/*
 * CreateDevice デバイスの登録
 * SUPPORTED APPLICATION TYPE: Web, ネイティブ
REQUIRED SCOPES: user.profile
* is_managedが managed または full_managed の場合
  * Request.body.client_id_listに設定されたID毎にアプリケーション種別がデバイスのOAuthClientが作成されます。(rsa_publickeyを指定する必要があります)
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateDeviceRequest
 */
func (a *DeviceApiService) CreateDevice(Ctx _context.Context) ApiCreateDeviceRequest {
	return ApiCreateDeviceRequest{
		ApiService: a,
		Ctx: Ctx,
	}
}

/*
 * Execute executes the request
 * @return SingleDevice
 */
func (a *DeviceApiService) CreateDeviceExecute(r ApiCreateDeviceRequest) (SingleDevice, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SingleDevice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "DeviceApiService.CreateDevice")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/devices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_deviceInfo == nil {
		return localVarReturnValue, nil, reportError("deviceInfo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_deviceInfo
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDevicePolicyRequest struct {
	Ctx _context.Context
	ApiService *DeviceApiService
	P_devicePolicyRequest *DevicePolicyRequest
}

func (r ApiCreateDevicePolicyRequest) DevicePolicyRequest(devicePolicyRequest DevicePolicyRequest) ApiCreateDevicePolicyRequest {
	r.P_devicePolicyRequest = &devicePolicyRequest
	return r
}

func (r ApiCreateDevicePolicyRequest) Execute() (DevicePolicy, *_nethttp.Response, error) {
	return r.ApiService.CreateDevicePolicyExecute(r)
}

/*
 * CreateDevicePolicy Method for CreateDevicePolicy
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateDevicePolicyRequest
 */
func (a *DeviceApiService) CreateDevicePolicy(Ctx _context.Context) ApiCreateDevicePolicyRequest {
	return ApiCreateDevicePolicyRequest{
		ApiService: a,
		Ctx: Ctx,
	}
}

/*
 * Execute executes the request
 * @return DevicePolicy
 */
func (a *DeviceApiService) CreateDevicePolicyExecute(r ApiCreateDevicePolicyRequest) (DevicePolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DevicePolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "DeviceApiService.CreateDevicePolicy")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/devices/group_policies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_devicePolicyRequest == nil {
		return localVarReturnValue, nil, reportError("devicePolicyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_devicePolicyRequest
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDeviceRequest struct {
	Ctx _context.Context
	ApiService *DeviceApiService
	P_deviceId string
}


func (r ApiDeleteDeviceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteDeviceExecute(r)
}

/*
 * DeleteDevice Method for DeleteDevice
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param deviceId デバイスID
 * @return ApiDeleteDeviceRequest
 */
func (a *DeviceApiService) DeleteDevice(Ctx _context.Context, deviceId string) ApiDeleteDeviceRequest {
	return ApiDeleteDeviceRequest{
		ApiService: a,
		Ctx: Ctx,
		P_deviceId: deviceId,
	}
}

/*
 * Execute executes the request
 */
func (a *DeviceApiService) DeleteDeviceExecute(r ApiDeleteDeviceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "DeviceApiService.DeleteDevice")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/devices/{device_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", _neturl.PathEscape(parameterToString(r.P_deviceId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeletePolicyRequest struct {
	Ctx _context.Context
	ApiService *DeviceApiService
	P_policyId string
}


func (r ApiDeletePolicyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeletePolicyExecute(r)
}

/*
 * DeletePolicy Method for DeletePolicy
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyId
 * @return ApiDeletePolicyRequest
 */
func (a *DeviceApiService) DeletePolicy(Ctx _context.Context, policyId string) ApiDeletePolicyRequest {
	return ApiDeletePolicyRequest{
		ApiService: a,
		Ctx: Ctx,
		P_policyId: policyId,
	}
}

/*
 * Execute executes the request
 */
func (a *DeviceApiService) DeletePolicyExecute(r ApiDeletePolicyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "DeviceApiService.DeletePolicy")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/devices/group_policies/{policy_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_id"+"}", _neturl.PathEscape(parameterToString(r.P_policyId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetDeviceRequest struct {
	Ctx _context.Context
	ApiService *DeviceApiService
	P_deviceId string
	P_lang *string
	P_isDev *bool
}

func (r ApiGetDeviceRequest) Lang(lang string) ApiGetDeviceRequest {
	r.P_lang = &lang
	return r
}
func (r ApiGetDeviceRequest) IsDev(isDev bool) ApiGetDeviceRequest {
	r.P_isDev = &isDev
	return r
}

func (r ApiGetDeviceRequest) Execute() (SingleDevice, *_nethttp.Response, error) {
	return r.ApiService.GetDeviceExecute(r)
}

/*
 * GetDevice 指定したidのデバイスの情報を取得する
 * SUPPORTED APPLICATION TYPE: Web, ネイティブ, クライアント
REQUIRED SCOPES: device.read
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param deviceId デバイスID
 * @return ApiGetDeviceRequest
 */
func (a *DeviceApiService) GetDevice(Ctx _context.Context, deviceId string) ApiGetDeviceRequest {
	return ApiGetDeviceRequest{
		ApiService: a,
		Ctx: Ctx,
		P_deviceId: deviceId,
	}
}

/*
 * Execute executes the request
 * @return SingleDevice
 */
func (a *DeviceApiService) GetDeviceExecute(r ApiGetDeviceRequest) (SingleDevice, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SingleDevice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "DeviceApiService.GetDevice")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/devices/{device_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", _neturl.PathEscape(parameterToString(r.P_deviceId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.P_lang != nil {
		localVarQueryParams.Add("lang", parameterToString(*r.P_lang, ""))
	}
	if r.P_isDev != nil {
		localVarQueryParams.Add("is_dev", parameterToString(*r.P_isDev, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeviceInventoryLatestRequest struct {
	Ctx _context.Context
	ApiService *DeviceApiService
	P_deviceId string
}


func (r ApiGetDeviceInventoryLatestRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.GetDeviceInventoryLatestExecute(r)
}

/*
 * GetDeviceInventoryLatest Method for GetDeviceInventoryLatest
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param deviceId
 * @return ApiGetDeviceInventoryLatestRequest
 */
func (a *DeviceApiService) GetDeviceInventoryLatest(Ctx _context.Context, deviceId string) ApiGetDeviceInventoryLatestRequest {
	return ApiGetDeviceInventoryLatestRequest{
		ApiService: a,
		Ctx: Ctx,
		P_deviceId: deviceId,
	}
}

/*
 * Execute executes the request
 * @return map[string]interface{}
 */
func (a *DeviceApiService) GetDeviceInventoryLatestExecute(r ApiGetDeviceInventoryLatestRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "DeviceApiService.GetDeviceInventoryLatest")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/devices/{device_id}/inventory/latest"
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", _neturl.PathEscape(parameterToString(r.P_deviceId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeviceMonitoringLatestRequest struct {
	Ctx _context.Context
	ApiService *DeviceApiService
	P_deviceId string
}


func (r ApiGetDeviceMonitoringLatestRequest) Execute() (SingleDeviceMonitoring, *_nethttp.Response, error) {
	return r.ApiService.GetDeviceMonitoringLatestExecute(r)
}

/*
 * GetDeviceMonitoringLatest Method for GetDeviceMonitoringLatest
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param deviceId
 * @return ApiGetDeviceMonitoringLatestRequest
 */
func (a *DeviceApiService) GetDeviceMonitoringLatest(Ctx _context.Context, deviceId string) ApiGetDeviceMonitoringLatestRequest {
	return ApiGetDeviceMonitoringLatestRequest{
		ApiService: a,
		Ctx: Ctx,
		P_deviceId: deviceId,
	}
}

/*
 * Execute executes the request
 * @return SingleDeviceMonitoring
 */
func (a *DeviceApiService) GetDeviceMonitoringLatestExecute(r ApiGetDeviceMonitoringLatestRequest) (SingleDeviceMonitoring, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SingleDeviceMonitoring
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "DeviceApiService.GetDeviceMonitoringLatest")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/devices/{device_id}/monitoring/latest"
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", _neturl.PathEscape(parameterToString(r.P_deviceId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeviceMonitoringsLatestRequest struct {
	Ctx _context.Context
	ApiService *DeviceApiService
	P_deviceMonitoringIDsRequest *DeviceMonitoringIDsRequest
}

func (r ApiGetDeviceMonitoringsLatestRequest) DeviceMonitoringIDsRequest(deviceMonitoringIDsRequest DeviceMonitoringIDsRequest) ApiGetDeviceMonitoringsLatestRequest {
	r.P_deviceMonitoringIDsRequest = &deviceMonitoringIDsRequest
	return r
}

func (r ApiGetDeviceMonitoringsLatestRequest) Execute() (MultipleDeviceMonitoring, *_nethttp.Response, error) {
	return r.ApiService.GetDeviceMonitoringsLatestExecute(r)
}

/*
 * GetDeviceMonitoringsLatest Method for GetDeviceMonitoringsLatest
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetDeviceMonitoringsLatestRequest
 */
func (a *DeviceApiService) GetDeviceMonitoringsLatest(Ctx _context.Context) ApiGetDeviceMonitoringsLatestRequest {
	return ApiGetDeviceMonitoringsLatestRequest{
		ApiService: a,
		Ctx: Ctx,
	}
}

/*
 * Execute executes the request
 * @return MultipleDeviceMonitoring
 */
func (a *DeviceApiService) GetDeviceMonitoringsLatestExecute(r ApiGetDeviceMonitoringsLatestRequest) (MultipleDeviceMonitoring, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MultipleDeviceMonitoring
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "DeviceApiService.GetDeviceMonitoringsLatest")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/devices/monitoring/latest"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_deviceMonitoringIDsRequest == nil {
		return localVarReturnValue, nil, reportError("deviceMonitoringIDsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_deviceMonitoringIDsRequest
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDevicePoliciesRequest struct {
	Ctx _context.Context
	ApiService *DeviceApiService
	P_limit *int64
	P_offset *int64
	P_order *string
	P_orderBy *string
	P_resourceOwnerId *string
}

func (r ApiGetDevicePoliciesRequest) Limit(limit int64) ApiGetDevicePoliciesRequest {
	r.P_limit = &limit
	return r
}
func (r ApiGetDevicePoliciesRequest) Offset(offset int64) ApiGetDevicePoliciesRequest {
	r.P_offset = &offset
	return r
}
func (r ApiGetDevicePoliciesRequest) Order(order string) ApiGetDevicePoliciesRequest {
	r.P_order = &order
	return r
}
func (r ApiGetDevicePoliciesRequest) OrderBy(orderBy string) ApiGetDevicePoliciesRequest {
	r.P_orderBy = &orderBy
	return r
}
func (r ApiGetDevicePoliciesRequest) ResourceOwnerId(resourceOwnerId string) ApiGetDevicePoliciesRequest {
	r.P_resourceOwnerId = &resourceOwnerId
	return r
}

func (r ApiGetDevicePoliciesRequest) Execute() (MultipleDevicePolicy, *_nethttp.Response, error) {
	return r.ApiService.GetDevicePoliciesExecute(r)
}

/*
 * GetDevicePolicies Method for GetDevicePolicies
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetDevicePoliciesRequest
 */
func (a *DeviceApiService) GetDevicePolicies(Ctx _context.Context) ApiGetDevicePoliciesRequest {
	return ApiGetDevicePoliciesRequest{
		ApiService: a,
		Ctx: Ctx,
	}
}

/*
 * Execute executes the request
 * @return MultipleDevicePolicy
 */
func (a *DeviceApiService) GetDevicePoliciesExecute(r ApiGetDevicePoliciesRequest) (MultipleDevicePolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MultipleDevicePolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "DeviceApiService.GetDevicePolicies")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/devices/group_policies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.P_limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.P_limit, ""))
	}
	if r.P_offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.P_offset, ""))
	}
	if r.P_order != nil {
		localVarQueryParams.Add("order", parameterToString(*r.P_order, ""))
	}
	if r.P_orderBy != nil {
		localVarQueryParams.Add("order_by", parameterToString(*r.P_orderBy, ""))
	}
	if r.P_resourceOwnerId != nil {
		localVarQueryParams.Add("resource_owner_id", parameterToString(*r.P_resourceOwnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDevicesRequest struct {
	Ctx _context.Context
	ApiService *DeviceApiService
	P_offset *int64
	P_limit *int64
	P_order *string
	P_orderBy *string
	P_lang *string
	P_isDev *bool
	P_isPublic *string
	P_resourceOwnerId *string
	P_name *string
	P_idNumber *string
	P_definitionId *string
	P_definitionTag *string
}

func (r ApiGetDevicesRequest) Offset(offset int64) ApiGetDevicesRequest {
	r.P_offset = &offset
	return r
}
func (r ApiGetDevicesRequest) Limit(limit int64) ApiGetDevicesRequest {
	r.P_limit = &limit
	return r
}
func (r ApiGetDevicesRequest) Order(order string) ApiGetDevicesRequest {
	r.P_order = &order
	return r
}
func (r ApiGetDevicesRequest) OrderBy(orderBy string) ApiGetDevicesRequest {
	r.P_orderBy = &orderBy
	return r
}
func (r ApiGetDevicesRequest) Lang(lang string) ApiGetDevicesRequest {
	r.P_lang = &lang
	return r
}
func (r ApiGetDevicesRequest) IsDev(isDev bool) ApiGetDevicesRequest {
	r.P_isDev = &isDev
	return r
}
func (r ApiGetDevicesRequest) IsPublic(isPublic string) ApiGetDevicesRequest {
	r.P_isPublic = &isPublic
	return r
}
func (r ApiGetDevicesRequest) ResourceOwnerId(resourceOwnerId string) ApiGetDevicesRequest {
	r.P_resourceOwnerId = &resourceOwnerId
	return r
}
func (r ApiGetDevicesRequest) Name(name string) ApiGetDevicesRequest {
	r.P_name = &name
	return r
}
func (r ApiGetDevicesRequest) IdNumber(idNumber string) ApiGetDevicesRequest {
	r.P_idNumber = &idNumber
	return r
}
func (r ApiGetDevicesRequest) DefinitionId(definitionId string) ApiGetDevicesRequest {
	r.P_definitionId = &definitionId
	return r
}
func (r ApiGetDevicesRequest) DefinitionTag(definitionTag string) ApiGetDevicesRequest {
	r.P_definitionTag = &definitionTag
	return r
}

func (r ApiGetDevicesRequest) Execute() (MultipleDevice, *_nethttp.Response, error) {
	return r.ApiService.GetDevicesExecute(r)
}

/*
 * GetDevices デバイスの一覧を取得する
 * SUPPORTED APPLICATION TYPE: Web, ネイティブ, クライアント
REQUIRED SCOPES: device.read
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetDevicesRequest
 */
func (a *DeviceApiService) GetDevices(Ctx _context.Context) ApiGetDevicesRequest {
	return ApiGetDevicesRequest{
		ApiService: a,
		Ctx: Ctx,
	}
}

/*
 * Execute executes the request
 * @return MultipleDevice
 */
func (a *DeviceApiService) GetDevicesExecute(r ApiGetDevicesRequest) (MultipleDevice, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MultipleDevice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "DeviceApiService.GetDevices")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/devices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.P_offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.P_offset, ""))
	}
	if r.P_limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.P_limit, ""))
	}
	if r.P_order != nil {
		localVarQueryParams.Add("order", parameterToString(*r.P_order, ""))
	}
	if r.P_orderBy != nil {
		localVarQueryParams.Add("order_by", parameterToString(*r.P_orderBy, ""))
	}
	if r.P_lang != nil {
		localVarQueryParams.Add("lang", parameterToString(*r.P_lang, ""))
	}
	if r.P_isDev != nil {
		localVarQueryParams.Add("is_dev", parameterToString(*r.P_isDev, ""))
	}
	if r.P_isPublic != nil {
		localVarQueryParams.Add("is_public", parameterToString(*r.P_isPublic, ""))
	}
	if r.P_resourceOwnerId != nil {
		localVarQueryParams.Add("resource_owner_id", parameterToString(*r.P_resourceOwnerId, ""))
	}
	if r.P_name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.P_name, ""))
	}
	if r.P_idNumber != nil {
		localVarQueryParams.Add("id_number", parameterToString(*r.P_idNumber, ""))
	}
	if r.P_definitionId != nil {
		localVarQueryParams.Add("definition_id", parameterToString(*r.P_definitionId, ""))
	}
	if r.P_definitionTag != nil {
		localVarQueryParams.Add("definition_tag", parameterToString(*r.P_definitionTag, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDeviceRequest struct {
	Ctx _context.Context
	ApiService *DeviceApiService
	P_deviceId string
	P_deviceUpdateRequest *DeviceUpdateRequest
}

func (r ApiUpdateDeviceRequest) DeviceUpdateRequest(deviceUpdateRequest DeviceUpdateRequest) ApiUpdateDeviceRequest {
	r.P_deviceUpdateRequest = &deviceUpdateRequest
	return r
}

func (r ApiUpdateDeviceRequest) Execute() (SingleDevice, *_nethttp.Response, error) {
	return r.ApiService.UpdateDeviceExecute(r)
}

/*
 * UpdateDevice 指定したidのデバイス情報を更新する
 * SUPPORTED APPLICATION TYPE: Web, ネイティブ, クライアント
REQUIRED SCOPES: device.write
* Request.body.client_id_listに設定されたアプリケーションクライアント毎にデバイスクライアントを作成します。
* is_managedをunmanagedに変更した場合は、device.client_listに登録されているデバイスクライアントをすべて削除します。(OAuthClient APIを利用してデバイスクライアントの削除を行います)
* is_managedがfull_managedのデバイス管理エージェント固有のデバイスクライアントに関しては、ディアクティベーションでのみ削除可能です。
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param deviceId デバイスID
 * @return ApiUpdateDeviceRequest
 */
func (a *DeviceApiService) UpdateDevice(Ctx _context.Context, deviceId string) ApiUpdateDeviceRequest {
	return ApiUpdateDeviceRequest{
		ApiService: a,
		Ctx: Ctx,
		P_deviceId: deviceId,
	}
}

/*
 * Execute executes the request
 * @return SingleDevice
 */
func (a *DeviceApiService) UpdateDeviceExecute(r ApiUpdateDeviceRequest) (SingleDevice, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SingleDevice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "DeviceApiService.UpdateDevice")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/devices/{device_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", _neturl.PathEscape(parameterToString(r.P_deviceId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_deviceUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("deviceUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_deviceUpdateRequest
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
