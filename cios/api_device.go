/*
 * Cios Openapi
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.1
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cios

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// DeviceApiService DeviceApi service
type DeviceApiService service

type ApiCreateDeviceRequest struct {
	Ctx _context.Context
	ApiService *DeviceApiService
	P_deviceInfo *DeviceInfo
}

func (r ApiCreateDeviceRequest) DeviceInfo(deviceInfo DeviceInfo) ApiCreateDeviceRequest {
	r.P_deviceInfo = &deviceInfo
	return r
}

func (r ApiCreateDeviceRequest) Execute() (SingleDevice, *_nethttp.Response, error) {
	return r.ApiService.CreateDeviceExecute(r)
}

/*
 * CreateDevice デバイスの登録
 * SUPPORTED APPLICATION TYPE: Web, ネイティブ
REQUIRED SCOPES: user.profile
* is_managedが managed または full_managed の場合
  * Request.body.client_id_listに設定されたID毎にアプリケーション種別がデバイスのOAuthClientが作成されます。(rsa_publickeyを指定する必要があります)
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateDeviceRequest
 */
func (a *DeviceApiService) CreateDevice(Ctx _context.Context) ApiCreateDeviceRequest {
	return ApiCreateDeviceRequest{
		ApiService: a,
		Ctx: Ctx,
	}
}

/*
 * Execute executes the request
 * @return SingleDevice
 */
func (a *DeviceApiService) CreateDeviceExecute(r ApiCreateDeviceRequest) (SingleDevice, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SingleDevice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "DeviceApiService.CreateDevice")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/devices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_deviceInfo == nil {
		return localVarReturnValue, nil, reportError("deviceInfo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_deviceInfo
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDeviceClientRequest struct {
	Ctx _context.Context
	ApiService *DeviceApiService
	P_deviceId string
	P_deviceClientRequest *DeviceClientRequest
}

func (r ApiCreateDeviceClientRequest) DeviceClientRequest(deviceClientRequest DeviceClientRequest) ApiCreateDeviceClientRequest {
	r.P_deviceClientRequest = &deviceClientRequest
	return r
}

func (r ApiCreateDeviceClientRequest) Execute() (DeviceClientList, *_nethttp.Response, error) {
	return r.ApiService.CreateDeviceClientExecute(r)
}

/*
 * CreateDeviceClient Method for CreateDeviceClient
 * * 指定したデバイスにクライアントを作成します。
* 指定したデバイスIDが存在しない場合は、エラー(404 Not Found)となります。
* 指定したデバイスにクライアントが存在しない状態で作成した場合、デバイス管理区分を一部管理に変更します。
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param deviceId
 * @return ApiCreateDeviceClientRequest
 */
func (a *DeviceApiService) CreateDeviceClient(Ctx _context.Context, deviceId string) ApiCreateDeviceClientRequest {
	return ApiCreateDeviceClientRequest{
		ApiService: a,
		Ctx: Ctx,
		P_deviceId: deviceId,
	}
}

/*
 * Execute executes the request
 * @return DeviceClientList
 */
func (a *DeviceApiService) CreateDeviceClientExecute(r ApiCreateDeviceClientRequest) (DeviceClientList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DeviceClientList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "DeviceApiService.CreateDeviceClient")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/devices/{device_id}/device_clients"
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", _neturl.PathEscape(parameterToString(r.P_deviceId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_deviceClientRequest == nil {
		return localVarReturnValue, nil, reportError("deviceClientRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_deviceClientRequest
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDevicePolicyRequest struct {
	Ctx _context.Context
	ApiService *DeviceApiService
	P_devicePolicyRequest *DevicePolicyRequest
}

func (r ApiCreateDevicePolicyRequest) DevicePolicyRequest(devicePolicyRequest DevicePolicyRequest) ApiCreateDevicePolicyRequest {
	r.P_devicePolicyRequest = &devicePolicyRequest
	return r
}

func (r ApiCreateDevicePolicyRequest) Execute() (DevicePolicy, *_nethttp.Response, error) {
	return r.ApiService.CreateDevicePolicyExecute(r)
}

/*
 * CreateDevicePolicy Method for CreateDevicePolicy
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateDevicePolicyRequest
 */
func (a *DeviceApiService) CreateDevicePolicy(Ctx _context.Context) ApiCreateDevicePolicyRequest {
	return ApiCreateDevicePolicyRequest{
		ApiService: a,
		Ctx: Ctx,
	}
}

/*
 * Execute executes the request
 * @return DevicePolicy
 */
func (a *DeviceApiService) CreateDevicePolicyExecute(r ApiCreateDevicePolicyRequest) (DevicePolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DevicePolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "DeviceApiService.CreateDevicePolicy")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/devices/group_policies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_devicePolicyRequest == nil {
		return localVarReturnValue, nil, reportError("devicePolicyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_devicePolicyRequest
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDeviceRequest struct {
	Ctx _context.Context
	ApiService *DeviceApiService
	P_deviceId string
}


func (r ApiDeleteDeviceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteDeviceExecute(r)
}

/*
 * DeleteDevice Method for DeleteDevice
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param deviceId デバイスID
 * @return ApiDeleteDeviceRequest
 */
func (a *DeviceApiService) DeleteDevice(Ctx _context.Context, deviceId string) ApiDeleteDeviceRequest {
	return ApiDeleteDeviceRequest{
		ApiService: a,
		Ctx: Ctx,
		P_deviceId: deviceId,
	}
}

/*
 * Execute executes the request
 */
func (a *DeviceApiService) DeleteDeviceExecute(r ApiDeleteDeviceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "DeviceApiService.DeleteDevice")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/devices/{device_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", _neturl.PathEscape(parameterToString(r.P_deviceId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteDeviceClientRequest struct {
	Ctx _context.Context
	ApiService *DeviceApiService
	P_deviceId string
	P_clientId string
}


func (r ApiDeleteDeviceClientRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteDeviceClientExecute(r)
}

/*
 * DeleteDeviceClient device.write
 * -| * 指定したアプリケーションクライアントIDに紐づくデバイスクライアントを削除します。 * 指定したデバイスID、またはアプリケーションクライアントIDが存在しない場合は、エラー(404 Not Found)となります。 * 指定したデバイスクライアントを削除後、デバイスに紐づくデバイスクライアントが存在しない場合は、デバイス管理区分を管理外に変更します。 * デバイス管理区分が完全管理のデバイス管理エージェント固有のデバイスクライアントに関しては、ディアクティベーションでのみ削除可能です。
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param deviceId
 * @param clientId
 * @return ApiDeleteDeviceClientRequest
 */
func (a *DeviceApiService) DeleteDeviceClient(Ctx _context.Context, deviceId string, clientId string) ApiDeleteDeviceClientRequest {
	return ApiDeleteDeviceClientRequest{
		ApiService: a,
		Ctx: Ctx,
		P_deviceId: deviceId,
		P_clientId: clientId,
	}
}

/*
 * Execute executes the request
 */
func (a *DeviceApiService) DeleteDeviceClientExecute(r ApiDeleteDeviceClientRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "DeviceApiService.DeleteDeviceClient")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/devices/{device_id}/device_clients/{client_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", _neturl.PathEscape(parameterToString(r.P_deviceId, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client_id"+"}", _neturl.PathEscape(parameterToString(r.P_clientId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeletePolicyRequest struct {
	Ctx _context.Context
	ApiService *DeviceApiService
	P_policyId string
}


func (r ApiDeletePolicyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeletePolicyExecute(r)
}

/*
 * DeletePolicy Method for DeletePolicy
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyId
 * @return ApiDeletePolicyRequest
 */
func (a *DeviceApiService) DeletePolicy(Ctx _context.Context, policyId string) ApiDeletePolicyRequest {
	return ApiDeletePolicyRequest{
		ApiService: a,
		Ctx: Ctx,
		P_policyId: policyId,
	}
}

/*
 * Execute executes the request
 */
func (a *DeviceApiService) DeletePolicyExecute(r ApiDeletePolicyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "DeviceApiService.DeletePolicy")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/devices/group_policies/{policy_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_id"+"}", _neturl.PathEscape(parameterToString(r.P_policyId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetDeviceRequest struct {
	Ctx _context.Context
	ApiService *DeviceApiService
	P_deviceId string
	P_lang *string
	P_isDev *bool
}

func (r ApiGetDeviceRequest) Lang(lang string) ApiGetDeviceRequest {
	r.P_lang = &lang
	return r
}
func (r ApiGetDeviceRequest) IsDev(isDev bool) ApiGetDeviceRequest {
	r.P_isDev = &isDev
	return r
}

func (r ApiGetDeviceRequest) Execute() (SingleDevice, *_nethttp.Response, error) {
	return r.ApiService.GetDeviceExecute(r)
}

/*
 * GetDevice 指定したidのデバイスの情報を取得する
 * SUPPORTED APPLICATION TYPE: Web, ネイティブ, クライアント
REQUIRED SCOPES: device.read
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param deviceId デバイスID
 * @return ApiGetDeviceRequest
 */
func (a *DeviceApiService) GetDevice(Ctx _context.Context, deviceId string) ApiGetDeviceRequest {
	return ApiGetDeviceRequest{
		ApiService: a,
		Ctx: Ctx,
		P_deviceId: deviceId,
	}
}

/*
 * Execute executes the request
 * @return SingleDevice
 */
func (a *DeviceApiService) GetDeviceExecute(r ApiGetDeviceRequest) (SingleDevice, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SingleDevice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "DeviceApiService.GetDevice")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/devices/{device_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", _neturl.PathEscape(parameterToString(r.P_deviceId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.P_lang != nil {
		localVarQueryParams.Add("lang", parameterToString(*r.P_lang, ""))
	}
	if r.P_isDev != nil {
		localVarQueryParams.Add("is_dev", parameterToString(*r.P_isDev, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeviceInventoryLatestRequest struct {
	Ctx _context.Context
	ApiService *DeviceApiService
	P_deviceId string
}


func (r ApiGetDeviceInventoryLatestRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.GetDeviceInventoryLatestExecute(r)
}

/*
 * GetDeviceInventoryLatest Method for GetDeviceInventoryLatest
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param deviceId
 * @return ApiGetDeviceInventoryLatestRequest
 */
func (a *DeviceApiService) GetDeviceInventoryLatest(Ctx _context.Context, deviceId string) ApiGetDeviceInventoryLatestRequest {
	return ApiGetDeviceInventoryLatestRequest{
		ApiService: a,
		Ctx: Ctx,
		P_deviceId: deviceId,
	}
}

/*
 * Execute executes the request
 * @return map[string]interface{}
 */
func (a *DeviceApiService) GetDeviceInventoryLatestExecute(r ApiGetDeviceInventoryLatestRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "DeviceApiService.GetDeviceInventoryLatest")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/devices/{device_id}/inventory/latest"
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", _neturl.PathEscape(parameterToString(r.P_deviceId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeviceMonitoringLatestRequest struct {
	Ctx _context.Context
	ApiService *DeviceApiService
	P_deviceId string
}


func (r ApiGetDeviceMonitoringLatestRequest) Execute() (SingleDeviceMonitoring, *_nethttp.Response, error) {
	return r.ApiService.GetDeviceMonitoringLatestExecute(r)
}

/*
 * GetDeviceMonitoringLatest Method for GetDeviceMonitoringLatest
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param deviceId
 * @return ApiGetDeviceMonitoringLatestRequest
 */
func (a *DeviceApiService) GetDeviceMonitoringLatest(Ctx _context.Context, deviceId string) ApiGetDeviceMonitoringLatestRequest {
	return ApiGetDeviceMonitoringLatestRequest{
		ApiService: a,
		Ctx: Ctx,
		P_deviceId: deviceId,
	}
}

/*
 * Execute executes the request
 * @return SingleDeviceMonitoring
 */
func (a *DeviceApiService) GetDeviceMonitoringLatestExecute(r ApiGetDeviceMonitoringLatestRequest) (SingleDeviceMonitoring, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SingleDeviceMonitoring
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "DeviceApiService.GetDeviceMonitoringLatest")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/devices/{device_id}/monitoring/latest"
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", _neturl.PathEscape(parameterToString(r.P_deviceId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeviceMonitoringsLatestRequest struct {
	Ctx _context.Context
	ApiService *DeviceApiService
	P_deviceMonitoringIDsRequest *DeviceMonitoringIDsRequest
}

func (r ApiGetDeviceMonitoringsLatestRequest) DeviceMonitoringIDsRequest(deviceMonitoringIDsRequest DeviceMonitoringIDsRequest) ApiGetDeviceMonitoringsLatestRequest {
	r.P_deviceMonitoringIDsRequest = &deviceMonitoringIDsRequest
	return r
}

func (r ApiGetDeviceMonitoringsLatestRequest) Execute() (MultipleDeviceMonitoring, *_nethttp.Response, error) {
	return r.ApiService.GetDeviceMonitoringsLatestExecute(r)
}

/*
 * GetDeviceMonitoringsLatest Method for GetDeviceMonitoringsLatest
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetDeviceMonitoringsLatestRequest
 */
func (a *DeviceApiService) GetDeviceMonitoringsLatest(Ctx _context.Context) ApiGetDeviceMonitoringsLatestRequest {
	return ApiGetDeviceMonitoringsLatestRequest{
		ApiService: a,
		Ctx: Ctx,
	}
}

/*
 * Execute executes the request
 * @return MultipleDeviceMonitoring
 */
func (a *DeviceApiService) GetDeviceMonitoringsLatestExecute(r ApiGetDeviceMonitoringsLatestRequest) (MultipleDeviceMonitoring, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MultipleDeviceMonitoring
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "DeviceApiService.GetDeviceMonitoringsLatest")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/devices/monitoring/latest"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_deviceMonitoringIDsRequest == nil {
		return localVarReturnValue, nil, reportError("deviceMonitoringIDsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_deviceMonitoringIDsRequest
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDevicePoliciesRequest struct {
	Ctx _context.Context
	ApiService *DeviceApiService
	P_limit *int64
	P_offset *int64
	P_order *string
	P_orderBy *string
	P_resourceOwnerId *string
}

func (r ApiGetDevicePoliciesRequest) Limit(limit int64) ApiGetDevicePoliciesRequest {
	r.P_limit = &limit
	return r
}
func (r ApiGetDevicePoliciesRequest) Offset(offset int64) ApiGetDevicePoliciesRequest {
	r.P_offset = &offset
	return r
}
func (r ApiGetDevicePoliciesRequest) Order(order string) ApiGetDevicePoliciesRequest {
	r.P_order = &order
	return r
}
func (r ApiGetDevicePoliciesRequest) OrderBy(orderBy string) ApiGetDevicePoliciesRequest {
	r.P_orderBy = &orderBy
	return r
}
func (r ApiGetDevicePoliciesRequest) ResourceOwnerId(resourceOwnerId string) ApiGetDevicePoliciesRequest {
	r.P_resourceOwnerId = &resourceOwnerId
	return r
}

func (r ApiGetDevicePoliciesRequest) Execute() (MultipleDevicePolicy, *_nethttp.Response, error) {
	return r.ApiService.GetDevicePoliciesExecute(r)
}

/*
 * GetDevicePolicies Method for GetDevicePolicies
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetDevicePoliciesRequest
 */
func (a *DeviceApiService) GetDevicePolicies(Ctx _context.Context) ApiGetDevicePoliciesRequest {
	return ApiGetDevicePoliciesRequest{
		ApiService: a,
		Ctx: Ctx,
	}
}

/*
 * Execute executes the request
 * @return MultipleDevicePolicy
 */
func (a *DeviceApiService) GetDevicePoliciesExecute(r ApiGetDevicePoliciesRequest) (MultipleDevicePolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MultipleDevicePolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "DeviceApiService.GetDevicePolicies")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/devices/group_policies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.P_limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.P_limit, ""))
	}
	if r.P_offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.P_offset, ""))
	}
	if r.P_order != nil {
		localVarQueryParams.Add("order", parameterToString(*r.P_order, ""))
	}
	if r.P_orderBy != nil {
		localVarQueryParams.Add("order_by", parameterToString(*r.P_orderBy, ""))
	}
	if r.P_resourceOwnerId != nil {
		localVarQueryParams.Add("resource_owner_id", parameterToString(*r.P_resourceOwnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeviceProfileRequest struct {
	Ctx _context.Context
	ApiService *DeviceApiService
	P_lang *string
	P_isDev *bool
}

func (r ApiGetDeviceProfileRequest) Lang(lang string) ApiGetDeviceProfileRequest {
	r.P_lang = &lang
	return r
}
func (r ApiGetDeviceProfileRequest) IsDev(isDev bool) ApiGetDeviceProfileRequest {
	r.P_isDev = &isDev
	return r
}

func (r ApiGetDeviceProfileRequest) Execute() (SingleDevice, *_nethttp.Response, error) {
	return r.ApiService.GetDeviceProfileExecute(r)
}

/*
 * GetDeviceProfile device.profile
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetDeviceProfileRequest
 */
func (a *DeviceApiService) GetDeviceProfile(Ctx _context.Context) ApiGetDeviceProfileRequest {
	return ApiGetDeviceProfileRequest{
		ApiService: a,
		Ctx: Ctx,
	}
}

/*
 * Execute executes the request
 * @return SingleDevice
 */
func (a *DeviceApiService) GetDeviceProfileExecute(r ApiGetDeviceProfileRequest) (SingleDevice, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SingleDevice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "DeviceApiService.GetDeviceProfile")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/devices/profile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.P_lang != nil {
		localVarQueryParams.Add("lang", parameterToString(*r.P_lang, ""))
	}
	if r.P_isDev != nil {
		localVarQueryParams.Add("is_dev", parameterToString(*r.P_isDev, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDevicesRequest struct {
	Ctx _context.Context
	ApiService *DeviceApiService
	P_offset *int64
	P_limit *int64
	P_order *string
	P_orderBy *string
	P_lang *string
	P_isDev *bool
	P_isPublic *string
	P_resourceOwnerId *string
	P_name *string
	P_idNumber *string
	P_definitionId *string
	P_definitionTag *string
}

func (r ApiGetDevicesRequest) Offset(offset int64) ApiGetDevicesRequest {
	r.P_offset = &offset
	return r
}
func (r ApiGetDevicesRequest) Limit(limit int64) ApiGetDevicesRequest {
	r.P_limit = &limit
	return r
}
func (r ApiGetDevicesRequest) Order(order string) ApiGetDevicesRequest {
	r.P_order = &order
	return r
}
func (r ApiGetDevicesRequest) OrderBy(orderBy string) ApiGetDevicesRequest {
	r.P_orderBy = &orderBy
	return r
}
func (r ApiGetDevicesRequest) Lang(lang string) ApiGetDevicesRequest {
	r.P_lang = &lang
	return r
}
func (r ApiGetDevicesRequest) IsDev(isDev bool) ApiGetDevicesRequest {
	r.P_isDev = &isDev
	return r
}
func (r ApiGetDevicesRequest) IsPublic(isPublic string) ApiGetDevicesRequest {
	r.P_isPublic = &isPublic
	return r
}
func (r ApiGetDevicesRequest) ResourceOwnerId(resourceOwnerId string) ApiGetDevicesRequest {
	r.P_resourceOwnerId = &resourceOwnerId
	return r
}
func (r ApiGetDevicesRequest) Name(name string) ApiGetDevicesRequest {
	r.P_name = &name
	return r
}
func (r ApiGetDevicesRequest) IdNumber(idNumber string) ApiGetDevicesRequest {
	r.P_idNumber = &idNumber
	return r
}
func (r ApiGetDevicesRequest) DefinitionId(definitionId string) ApiGetDevicesRequest {
	r.P_definitionId = &definitionId
	return r
}
func (r ApiGetDevicesRequest) DefinitionTag(definitionTag string) ApiGetDevicesRequest {
	r.P_definitionTag = &definitionTag
	return r
}

func (r ApiGetDevicesRequest) Execute() (MultipleDevice, *_nethttp.Response, error) {
	return r.ApiService.GetDevicesExecute(r)
}

/*
 * GetDevices デバイスの一覧を取得する
 * SUPPORTED APPLICATION TYPE: Web, ネイティブ, クライアント
REQUIRED SCOPES: device.read
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetDevicesRequest
 */
func (a *DeviceApiService) GetDevices(Ctx _context.Context) ApiGetDevicesRequest {
	return ApiGetDevicesRequest{
		ApiService: a,
		Ctx: Ctx,
	}
}

/*
 * Execute executes the request
 * @return MultipleDevice
 */
func (a *DeviceApiService) GetDevicesExecute(r ApiGetDevicesRequest) (MultipleDevice, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MultipleDevice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "DeviceApiService.GetDevices")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/devices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.P_offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.P_offset, ""))
	}
	if r.P_limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.P_limit, ""))
	}
	if r.P_order != nil {
		localVarQueryParams.Add("order", parameterToString(*r.P_order, ""))
	}
	if r.P_orderBy != nil {
		localVarQueryParams.Add("order_by", parameterToString(*r.P_orderBy, ""))
	}
	if r.P_lang != nil {
		localVarQueryParams.Add("lang", parameterToString(*r.P_lang, ""))
	}
	if r.P_isDev != nil {
		localVarQueryParams.Add("is_dev", parameterToString(*r.P_isDev, ""))
	}
	if r.P_isPublic != nil {
		localVarQueryParams.Add("is_public", parameterToString(*r.P_isPublic, ""))
	}
	if r.P_resourceOwnerId != nil {
		localVarQueryParams.Add("resource_owner_id", parameterToString(*r.P_resourceOwnerId, ""))
	}
	if r.P_name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.P_name, ""))
	}
	if r.P_idNumber != nil {
		localVarQueryParams.Add("id_number", parameterToString(*r.P_idNumber, ""))
	}
	if r.P_definitionId != nil {
		localVarQueryParams.Add("definition_id", parameterToString(*r.P_definitionId, ""))
	}
	if r.P_definitionTag != nil {
		localVarQueryParams.Add("definition_tag", parameterToString(*r.P_definitionTag, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDeviceRequest struct {
	Ctx _context.Context
	ApiService *DeviceApiService
	P_deviceId string
	P_deviceUpdateRequest *DeviceUpdateRequest
}

func (r ApiUpdateDeviceRequest) DeviceUpdateRequest(deviceUpdateRequest DeviceUpdateRequest) ApiUpdateDeviceRequest {
	r.P_deviceUpdateRequest = &deviceUpdateRequest
	return r
}

func (r ApiUpdateDeviceRequest) Execute() (SingleDevice, *_nethttp.Response, error) {
	return r.ApiService.UpdateDeviceExecute(r)
}

/*
 * UpdateDevice 指定したidのデバイス情報を更新する
 * SUPPORTED APPLICATION TYPE: Web, ネイティブ, クライアント
REQUIRED SCOPES: device.write
* Request.body.client_id_listに設定されたアプリケーションクライアント毎にデバイスクライアントを作成します。
* is_managedをunmanagedに変更した場合は、device.client_listに登録されているデバイスクライアントをすべて削除します。(OAuthClient APIを利用してデバイスクライアントの削除を行います)
* is_managedがfull_managedのデバイス管理エージェント固有のデバイスクライアントに関しては、ディアクティベーションでのみ削除可能です。
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param deviceId デバイスID
 * @return ApiUpdateDeviceRequest
 */
func (a *DeviceApiService) UpdateDevice(Ctx _context.Context, deviceId string) ApiUpdateDeviceRequest {
	return ApiUpdateDeviceRequest{
		ApiService: a,
		Ctx: Ctx,
		P_deviceId: deviceId,
	}
}

/*
 * Execute executes the request
 * @return SingleDevice
 */
func (a *DeviceApiService) UpdateDeviceExecute(r ApiUpdateDeviceRequest) (SingleDevice, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SingleDevice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "DeviceApiService.UpdateDevice")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/devices/{device_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", _neturl.PathEscape(parameterToString(r.P_deviceId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_deviceUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("deviceUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_deviceUpdateRequest
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDeviceClientRequest struct {
	Ctx _context.Context
	ApiService *DeviceApiService
	P_deviceId string
	P_clientId string
	P_rsaPublicKey *RsaPublicKey
}

func (r ApiUpdateDeviceClientRequest) RsaPublicKey(rsaPublicKey RsaPublicKey) ApiUpdateDeviceClientRequest {
	r.P_rsaPublicKey = &rsaPublicKey
	return r
}

func (r ApiUpdateDeviceClientRequest) Execute() (SingleDeviceClientList, *_nethttp.Response, error) {
	return r.ApiService.UpdateDeviceClientExecute(r)
}

/*
 * UpdateDeviceClient device.write
 * -| * 指定したアプリケーションクライアントIDに紐づくデバイスクライアントのRSA公開鍵を更新します。 * 指定したデバイスID、またはアプリケーションクライアントIDが存在しない場合は、エラー(404 Not Found)となります。
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param deviceId
 * @param clientId
 * @return ApiUpdateDeviceClientRequest
 */
func (a *DeviceApiService) UpdateDeviceClient(Ctx _context.Context, deviceId string, clientId string) ApiUpdateDeviceClientRequest {
	return ApiUpdateDeviceClientRequest{
		ApiService: a,
		Ctx: Ctx,
		P_deviceId: deviceId,
		P_clientId: clientId,
	}
}

/*
 * Execute executes the request
 * @return SingleDeviceClientList
 */
func (a *DeviceApiService) UpdateDeviceClientExecute(r ApiUpdateDeviceClientRequest) (SingleDeviceClientList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SingleDeviceClientList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "DeviceApiService.UpdateDeviceClient")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/devices/{device_id}/device_clients/{client_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", _neturl.PathEscape(parameterToString(r.P_deviceId, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client_id"+"}", _neturl.PathEscape(parameterToString(r.P_clientId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_rsaPublicKey == nil {
		return localVarReturnValue, nil, reportError("rsaPublicKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_rsaPublicKey
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
