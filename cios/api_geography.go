/*
 * Cios Openapi
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.1
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cios

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// GeographyApiService GeographyApi service
type GeographyApiService service

type ApiCreateCircleRequest struct {
	Ctx _context.Context
	ApiService *GeographyApiService
	P_circle *Circle
}

func (r ApiCreateCircleRequest) Circle(circle Circle) ApiCreateCircleRequest {
	r.P_circle = &circle
	return r
}

func (r ApiCreateCircleRequest) Execute() (SingleCircle, *_nethttp.Response, error) {
	return r.ApiService.CreateCircleExecute(r)
}

/*
 * CreateCircle Method for CreateCircle
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateCircleRequest
 */
func (a *GeographyApiService) CreateCircle(Ctx _context.Context) ApiCreateCircleRequest {
	return ApiCreateCircleRequest{
		ApiService: a,
		Ctx: Ctx,
	}
}

/*
 * Execute executes the request
 * @return SingleCircle
 */
func (a *GeographyApiService) CreateCircleExecute(r ApiCreateCircleRequest) (SingleCircle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SingleCircle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "GeographyApiService.CreateCircle")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/geo/circles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_circle == nil {
		return localVarReturnValue, nil, reportError("circle is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_circle
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePointRequest struct {
	Ctx _context.Context
	ApiService *GeographyApiService
	P_pointRequest *PointRequest
}

func (r ApiCreatePointRequest) PointRequest(pointRequest PointRequest) ApiCreatePointRequest {
	r.P_pointRequest = &pointRequest
	return r
}

func (r ApiCreatePointRequest) Execute() (SinglePoint, *_nethttp.Response, error) {
	return r.ApiService.CreatePointExecute(r)
}

/*
 * CreatePoint Method for CreatePoint
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreatePointRequest
 */
func (a *GeographyApiService) CreatePoint(Ctx _context.Context) ApiCreatePointRequest {
	return ApiCreatePointRequest{
		ApiService: a,
		Ctx: Ctx,
	}
}

/*
 * Execute executes the request
 * @return SinglePoint
 */
func (a *GeographyApiService) CreatePointExecute(r ApiCreatePointRequest) (SinglePoint, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SinglePoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "GeographyApiService.CreatePoint")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/geo/points"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_pointRequest == nil {
		return localVarReturnValue, nil, reportError("pointRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_pointRequest
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateRouteRequest struct {
	Ctx _context.Context
	ApiService *GeographyApiService
	P_route *Route
}

func (r ApiCreateRouteRequest) Route(route Route) ApiCreateRouteRequest {
	r.P_route = &route
	return r
}

func (r ApiCreateRouteRequest) Execute() (SingleRoute, *_nethttp.Response, error) {
	return r.ApiService.CreateRouteExecute(r)
}

/*
 * CreateRoute Method for CreateRoute
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateRouteRequest
 */
func (a *GeographyApiService) CreateRoute(Ctx _context.Context) ApiCreateRouteRequest {
	return ApiCreateRouteRequest{
		ApiService: a,
		Ctx: Ctx,
	}
}

/*
 * Execute executes the request
 * @return SingleRoute
 */
func (a *GeographyApiService) CreateRouteExecute(r ApiCreateRouteRequest) (SingleRoute, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SingleRoute
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "GeographyApiService.CreateRoute")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/geo/routes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_route == nil {
		return localVarReturnValue, nil, reportError("route is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_route
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCircleRequest struct {
	Ctx _context.Context
	ApiService *GeographyApiService
	P_circleId string
}


func (r ApiDeleteCircleRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteCircleExecute(r)
}

/*
 * DeleteCircle Method for DeleteCircle
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param circleId
 * @return ApiDeleteCircleRequest
 */
func (a *GeographyApiService) DeleteCircle(Ctx _context.Context, circleId string) ApiDeleteCircleRequest {
	return ApiDeleteCircleRequest{
		ApiService: a,
		Ctx: Ctx,
		P_circleId: circleId,
	}
}

/*
 * Execute executes the request
 */
func (a *GeographyApiService) DeleteCircleExecute(r ApiDeleteCircleRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "GeographyApiService.DeleteCircle")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/geo/circles/{circles_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"circle_id"+"}", _neturl.PathEscape(parameterToString(r.P_circleId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeletePointRequest struct {
	Ctx _context.Context
	ApiService *GeographyApiService
	P_pointId string
}


func (r ApiDeletePointRequest) Execute() (SinglePoint, *_nethttp.Response, error) {
	return r.ApiService.DeletePointExecute(r)
}

/*
 * DeletePoint Method for DeletePoint
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pointId
 * @return ApiDeletePointRequest
 */
func (a *GeographyApiService) DeletePoint(Ctx _context.Context, pointId string) ApiDeletePointRequest {
	return ApiDeletePointRequest{
		ApiService: a,
		Ctx: Ctx,
		P_pointId: pointId,
	}
}

/*
 * Execute executes the request
 * @return SinglePoint
 */
func (a *GeographyApiService) DeletePointExecute(r ApiDeletePointRequest) (SinglePoint, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SinglePoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "GeographyApiService.DeletePoint")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/geo/points/{point_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"point_id"+"}", _neturl.PathEscape(parameterToString(r.P_pointId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteRouteRequest struct {
	Ctx _context.Context
	ApiService *GeographyApiService
	P_routeId string
}


func (r ApiDeleteRouteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteRouteExecute(r)
}

/*
 * DeleteRoute Method for DeleteRoute
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param routeId
 * @return ApiDeleteRouteRequest
 */
func (a *GeographyApiService) DeleteRoute(Ctx _context.Context, routeId string) ApiDeleteRouteRequest {
	return ApiDeleteRouteRequest{
		ApiService: a,
		Ctx: Ctx,
		P_routeId: routeId,
	}
}

/*
 * Execute executes the request
 */
func (a *GeographyApiService) DeleteRouteExecute(r ApiDeleteRouteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "GeographyApiService.DeleteRoute")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/geo/routes/{routes_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"route_id"+"}", _neturl.PathEscape(parameterToString(r.P_routeId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetCircleRequest struct {
	Ctx _context.Context
	ApiService *GeographyApiService
	P_circleId string
	P_lang *string
	P_isDev *bool
}

func (r ApiGetCircleRequest) Lang(lang string) ApiGetCircleRequest {
	r.P_lang = &lang
	return r
}
func (r ApiGetCircleRequest) IsDev(isDev bool) ApiGetCircleRequest {
	r.P_isDev = &isDev
	return r
}

func (r ApiGetCircleRequest) Execute() (SingleCircle, *_nethttp.Response, error) {
	return r.ApiService.GetCircleExecute(r)
}

/*
 * GetCircle Method for GetCircle
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param circleId
 * @return ApiGetCircleRequest
 */
func (a *GeographyApiService) GetCircle(Ctx _context.Context, circleId string) ApiGetCircleRequest {
	return ApiGetCircleRequest{
		ApiService: a,
		Ctx: Ctx,
		P_circleId: circleId,
	}
}

/*
 * Execute executes the request
 * @return SingleCircle
 */
func (a *GeographyApiService) GetCircleExecute(r ApiGetCircleRequest) (SingleCircle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SingleCircle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "GeographyApiService.GetCircle")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/geo/circles/{circles_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"circle_id"+"}", _neturl.PathEscape(parameterToString(r.P_circleId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.P_lang != nil {
		localVarQueryParams.Add("lang", parameterToString(*r.P_lang, ""))
	}
	if r.P_isDev != nil {
		localVarQueryParams.Add("is_dev", parameterToString(*r.P_isDev, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCirclesRequest struct {
	Ctx _context.Context
	ApiService *GeographyApiService
	P_name *string
	P_label *string
	P_isPublic *string
	P_resourceOwnerId *string
	P_sort *string
	P_top *int32
	P_skip *int32
	P_lang *string
	P_isDev *bool
}

func (r ApiGetCirclesRequest) Name(name string) ApiGetCirclesRequest {
	r.P_name = &name
	return r
}
func (r ApiGetCirclesRequest) Label(label string) ApiGetCirclesRequest {
	r.P_label = &label
	return r
}
func (r ApiGetCirclesRequest) IsPublic(isPublic string) ApiGetCirclesRequest {
	r.P_isPublic = &isPublic
	return r
}
func (r ApiGetCirclesRequest) ResourceOwnerId(resourceOwnerId string) ApiGetCirclesRequest {
	r.P_resourceOwnerId = &resourceOwnerId
	return r
}
func (r ApiGetCirclesRequest) Sort(sort string) ApiGetCirclesRequest {
	r.P_sort = &sort
	return r
}
func (r ApiGetCirclesRequest) Top(top int32) ApiGetCirclesRequest {
	r.P_top = &top
	return r
}
func (r ApiGetCirclesRequest) Skip(skip int32) ApiGetCirclesRequest {
	r.P_skip = &skip
	return r
}
func (r ApiGetCirclesRequest) Lang(lang string) ApiGetCirclesRequest {
	r.P_lang = &lang
	return r
}
func (r ApiGetCirclesRequest) IsDev(isDev bool) ApiGetCirclesRequest {
	r.P_isDev = &isDev
	return r
}

func (r ApiGetCirclesRequest) Execute() (MultipleCircle, *_nethttp.Response, error) {
	return r.ApiService.GetCirclesExecute(r)
}

/*
 * GetCircles Method for GetCircles
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetCirclesRequest
 */
func (a *GeographyApiService) GetCircles(Ctx _context.Context) ApiGetCirclesRequest {
	return ApiGetCirclesRequest{
		ApiService: a,
		Ctx: Ctx,
	}
}

/*
 * Execute executes the request
 * @return MultipleCircle
 */
func (a *GeographyApiService) GetCirclesExecute(r ApiGetCirclesRequest) (MultipleCircle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MultipleCircle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "GeographyApiService.GetCircles")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/geo/circles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.P_name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.P_name, ""))
	}
	if r.P_label != nil {
		localVarQueryParams.Add("label", parameterToString(*r.P_label, ""))
	}
	if r.P_isPublic != nil {
		localVarQueryParams.Add("is_public", parameterToString(*r.P_isPublic, ""))
	}
	if r.P_resourceOwnerId != nil {
		localVarQueryParams.Add("resource_owner_id", parameterToString(*r.P_resourceOwnerId, ""))
	}
	if r.P_sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.P_sort, ""))
	}
	if r.P_top != nil {
		localVarQueryParams.Add("top", parameterToString(*r.P_top, ""))
	}
	if r.P_skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.P_skip, ""))
	}
	if r.P_lang != nil {
		localVarQueryParams.Add("lang", parameterToString(*r.P_lang, ""))
	}
	if r.P_isDev != nil {
		localVarQueryParams.Add("is_dev", parameterToString(*r.P_isDev, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPointRequest struct {
	Ctx _context.Context
	ApiService *GeographyApiService
	P_pointId string
	P_lang *string
	P_isDev *bool
}

func (r ApiGetPointRequest) Lang(lang string) ApiGetPointRequest {
	r.P_lang = &lang
	return r
}
func (r ApiGetPointRequest) IsDev(isDev bool) ApiGetPointRequest {
	r.P_isDev = &isDev
	return r
}

func (r ApiGetPointRequest) Execute() (SinglePoint, *_nethttp.Response, error) {
	return r.ApiService.GetPointExecute(r)
}

/*
 * GetPoint Method for GetPoint
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pointId
 * @return ApiGetPointRequest
 */
func (a *GeographyApiService) GetPoint(Ctx _context.Context, pointId string) ApiGetPointRequest {
	return ApiGetPointRequest{
		ApiService: a,
		Ctx: Ctx,
		P_pointId: pointId,
	}
}

/*
 * Execute executes the request
 * @return SinglePoint
 */
func (a *GeographyApiService) GetPointExecute(r ApiGetPointRequest) (SinglePoint, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SinglePoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "GeographyApiService.GetPoint")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/geo/points/{point_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"point_id"+"}", _neturl.PathEscape(parameterToString(r.P_pointId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.P_lang != nil {
		localVarQueryParams.Add("lang", parameterToString(*r.P_lang, ""))
	}
	if r.P_isDev != nil {
		localVarQueryParams.Add("is_dev", parameterToString(*r.P_isDev, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPointsRequest struct {
	Ctx _context.Context
	ApiService *GeographyApiService
	P_name *string
	P_label *string
	P_isPublic *string
	P_resourceOwnerId *string
	P_sort *string
	P_top *int32
	P_skip *int32
	P_lang *string
	P_isDev *bool
}

func (r ApiGetPointsRequest) Name(name string) ApiGetPointsRequest {
	r.P_name = &name
	return r
}
func (r ApiGetPointsRequest) Label(label string) ApiGetPointsRequest {
	r.P_label = &label
	return r
}
func (r ApiGetPointsRequest) IsPublic(isPublic string) ApiGetPointsRequest {
	r.P_isPublic = &isPublic
	return r
}
func (r ApiGetPointsRequest) ResourceOwnerId(resourceOwnerId string) ApiGetPointsRequest {
	r.P_resourceOwnerId = &resourceOwnerId
	return r
}
func (r ApiGetPointsRequest) Sort(sort string) ApiGetPointsRequest {
	r.P_sort = &sort
	return r
}
func (r ApiGetPointsRequest) Top(top int32) ApiGetPointsRequest {
	r.P_top = &top
	return r
}
func (r ApiGetPointsRequest) Skip(skip int32) ApiGetPointsRequest {
	r.P_skip = &skip
	return r
}
func (r ApiGetPointsRequest) Lang(lang string) ApiGetPointsRequest {
	r.P_lang = &lang
	return r
}
func (r ApiGetPointsRequest) IsDev(isDev bool) ApiGetPointsRequest {
	r.P_isDev = &isDev
	return r
}

func (r ApiGetPointsRequest) Execute() (MultiplePoint, *_nethttp.Response, error) {
	return r.ApiService.GetPointsExecute(r)
}

/*
 * GetPoints Method for GetPoints
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetPointsRequest
 */
func (a *GeographyApiService) GetPoints(Ctx _context.Context) ApiGetPointsRequest {
	return ApiGetPointsRequest{
		ApiService: a,
		Ctx: Ctx,
	}
}

/*
 * Execute executes the request
 * @return MultiplePoint
 */
func (a *GeographyApiService) GetPointsExecute(r ApiGetPointsRequest) (MultiplePoint, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MultiplePoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "GeographyApiService.GetPoints")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/geo/points"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.P_name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.P_name, ""))
	}
	if r.P_label != nil {
		localVarQueryParams.Add("label", parameterToString(*r.P_label, ""))
	}
	if r.P_isPublic != nil {
		localVarQueryParams.Add("is_public", parameterToString(*r.P_isPublic, ""))
	}
	if r.P_resourceOwnerId != nil {
		localVarQueryParams.Add("resource_owner_id", parameterToString(*r.P_resourceOwnerId, ""))
	}
	if r.P_sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.P_sort, ""))
	}
	if r.P_top != nil {
		localVarQueryParams.Add("top", parameterToString(*r.P_top, ""))
	}
	if r.P_skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.P_skip, ""))
	}
	if r.P_lang != nil {
		localVarQueryParams.Add("lang", parameterToString(*r.P_lang, ""))
	}
	if r.P_isDev != nil {
		localVarQueryParams.Add("is_dev", parameterToString(*r.P_isDev, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRouteRequest struct {
	Ctx _context.Context
	ApiService *GeographyApiService
	P_routeId string
	P_lang *string
	P_isDev *bool
}

func (r ApiGetRouteRequest) Lang(lang string) ApiGetRouteRequest {
	r.P_lang = &lang
	return r
}
func (r ApiGetRouteRequest) IsDev(isDev bool) ApiGetRouteRequest {
	r.P_isDev = &isDev
	return r
}

func (r ApiGetRouteRequest) Execute() (SingleRoute, *_nethttp.Response, error) {
	return r.ApiService.GetRouteExecute(r)
}

/*
 * GetRoute Method for GetRoute
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param routeId
 * @return ApiGetRouteRequest
 */
func (a *GeographyApiService) GetRoute(Ctx _context.Context, routeId string) ApiGetRouteRequest {
	return ApiGetRouteRequest{
		ApiService: a,
		Ctx: Ctx,
		P_routeId: routeId,
	}
}

/*
 * Execute executes the request
 * @return SingleRoute
 */
func (a *GeographyApiService) GetRouteExecute(r ApiGetRouteRequest) (SingleRoute, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SingleRoute
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "GeographyApiService.GetRoute")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/geo/routes/{routes_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"route_id"+"}", _neturl.PathEscape(parameterToString(r.P_routeId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.P_lang != nil {
		localVarQueryParams.Add("lang", parameterToString(*r.P_lang, ""))
	}
	if r.P_isDev != nil {
		localVarQueryParams.Add("is_dev", parameterToString(*r.P_isDev, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoutesRequest struct {
	Ctx _context.Context
	ApiService *GeographyApiService
	P_name *string
	P_label *string
	P_isPublic *string
	P_resourceOwnerId *string
	P_sort *string
	P_top *int32
	P_skip *int32
	P_lang *string
	P_isDev *bool
}

func (r ApiGetRoutesRequest) Name(name string) ApiGetRoutesRequest {
	r.P_name = &name
	return r
}
func (r ApiGetRoutesRequest) Label(label string) ApiGetRoutesRequest {
	r.P_label = &label
	return r
}
func (r ApiGetRoutesRequest) IsPublic(isPublic string) ApiGetRoutesRequest {
	r.P_isPublic = &isPublic
	return r
}
func (r ApiGetRoutesRequest) ResourceOwnerId(resourceOwnerId string) ApiGetRoutesRequest {
	r.P_resourceOwnerId = &resourceOwnerId
	return r
}
func (r ApiGetRoutesRequest) Sort(sort string) ApiGetRoutesRequest {
	r.P_sort = &sort
	return r
}
func (r ApiGetRoutesRequest) Top(top int32) ApiGetRoutesRequest {
	r.P_top = &top
	return r
}
func (r ApiGetRoutesRequest) Skip(skip int32) ApiGetRoutesRequest {
	r.P_skip = &skip
	return r
}
func (r ApiGetRoutesRequest) Lang(lang string) ApiGetRoutesRequest {
	r.P_lang = &lang
	return r
}
func (r ApiGetRoutesRequest) IsDev(isDev bool) ApiGetRoutesRequest {
	r.P_isDev = &isDev
	return r
}

func (r ApiGetRoutesRequest) Execute() (MultipleRoute, *_nethttp.Response, error) {
	return r.ApiService.GetRoutesExecute(r)
}

/*
 * GetRoutes Method for GetRoutes
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetRoutesRequest
 */
func (a *GeographyApiService) GetRoutes(Ctx _context.Context) ApiGetRoutesRequest {
	return ApiGetRoutesRequest{
		ApiService: a,
		Ctx: Ctx,
	}
}

/*
 * Execute executes the request
 * @return MultipleRoute
 */
func (a *GeographyApiService) GetRoutesExecute(r ApiGetRoutesRequest) (MultipleRoute, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MultipleRoute
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "GeographyApiService.GetRoutes")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/geo/routes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.P_name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.P_name, ""))
	}
	if r.P_label != nil {
		localVarQueryParams.Add("label", parameterToString(*r.P_label, ""))
	}
	if r.P_isPublic != nil {
		localVarQueryParams.Add("is_public", parameterToString(*r.P_isPublic, ""))
	}
	if r.P_resourceOwnerId != nil {
		localVarQueryParams.Add("resource_owner_id", parameterToString(*r.P_resourceOwnerId, ""))
	}
	if r.P_sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.P_sort, ""))
	}
	if r.P_top != nil {
		localVarQueryParams.Add("top", parameterToString(*r.P_top, ""))
	}
	if r.P_skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.P_skip, ""))
	}
	if r.P_lang != nil {
		localVarQueryParams.Add("lang", parameterToString(*r.P_lang, ""))
	}
	if r.P_isDev != nil {
		localVarQueryParams.Add("is_dev", parameterToString(*r.P_isDev, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCircleRequest struct {
	Ctx _context.Context
	ApiService *GeographyApiService
	P_circleId string
	P_displayInfo *[]DisplayInfo
}

func (r ApiUpdateCircleRequest) DisplayInfo(displayInfo []DisplayInfo) ApiUpdateCircleRequest {
	r.P_displayInfo = &displayInfo
	return r
}

func (r ApiUpdateCircleRequest) Execute() (SingleCircle, *_nethttp.Response, error) {
	return r.ApiService.UpdateCircleExecute(r)
}

/*
 * UpdateCircle Method for UpdateCircle
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param circleId
 * @return ApiUpdateCircleRequest
 */
func (a *GeographyApiService) UpdateCircle(Ctx _context.Context, circleId string) ApiUpdateCircleRequest {
	return ApiUpdateCircleRequest{
		ApiService: a,
		Ctx: Ctx,
		P_circleId: circleId,
	}
}

/*
 * Execute executes the request
 * @return SingleCircle
 */
func (a *GeographyApiService) UpdateCircleExecute(r ApiUpdateCircleRequest) (SingleCircle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SingleCircle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "GeographyApiService.UpdateCircle")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/geo/circles/{circles_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"circle_id"+"}", _neturl.PathEscape(parameterToString(r.P_circleId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_displayInfo
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePointRequest struct {
	Ctx _context.Context
	ApiService *GeographyApiService
	P_pointId string
	P_displayInfo *[]DisplayInfo
}

func (r ApiUpdatePointRequest) DisplayInfo(displayInfo []DisplayInfo) ApiUpdatePointRequest {
	r.P_displayInfo = &displayInfo
	return r
}

func (r ApiUpdatePointRequest) Execute() (SinglePoint, *_nethttp.Response, error) {
	return r.ApiService.UpdatePointExecute(r)
}

/*
 * UpdatePoint Method for UpdatePoint
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pointId
 * @return ApiUpdatePointRequest
 */
func (a *GeographyApiService) UpdatePoint(Ctx _context.Context, pointId string) ApiUpdatePointRequest {
	return ApiUpdatePointRequest{
		ApiService: a,
		Ctx: Ctx,
		P_pointId: pointId,
	}
}

/*
 * Execute executes the request
 * @return SinglePoint
 */
func (a *GeographyApiService) UpdatePointExecute(r ApiUpdatePointRequest) (SinglePoint, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SinglePoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "GeographyApiService.UpdatePoint")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/geo/points/{point_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"point_id"+"}", _neturl.PathEscape(parameterToString(r.P_pointId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_displayInfo
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateRouteRequest struct {
	Ctx _context.Context
	ApiService *GeographyApiService
	P_routeId string
	P_displayInfo *[]DisplayInfo
}

func (r ApiUpdateRouteRequest) DisplayInfo(displayInfo []DisplayInfo) ApiUpdateRouteRequest {
	r.P_displayInfo = &displayInfo
	return r
}

func (r ApiUpdateRouteRequest) Execute() (SingleRoute, *_nethttp.Response, error) {
	return r.ApiService.UpdateRouteExecute(r)
}

/*
 * UpdateRoute Method for UpdateRoute
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param routeId
 * @return ApiUpdateRouteRequest
 */
func (a *GeographyApiService) UpdateRoute(Ctx _context.Context, routeId string) ApiUpdateRouteRequest {
	return ApiUpdateRouteRequest{
		ApiService: a,
		Ctx: Ctx,
		P_routeId: routeId,
	}
}

/*
 * Execute executes the request
 * @return SingleRoute
 */
func (a *GeographyApiService) UpdateRouteExecute(r ApiUpdateRouteRequest) (SingleRoute, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SingleRoute
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "GeographyApiService.UpdateRoute")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/geo/routes/{routes_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"route_id"+"}", _neturl.PathEscape(parameterToString(r.P_routeId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_displayInfo
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
