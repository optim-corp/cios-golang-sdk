/*
 * Cios Openapi
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.1
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cios

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// GroupApiService GroupApi service
type GroupApiService service

type ApiCreateGroupRequest struct {
	Ctx _context.Context
	ApiService *GroupApiService
	P_groupCreateRequest *GroupCreateRequest
}

func (r ApiCreateGroupRequest) GroupCreateRequest(groupCreateRequest GroupCreateRequest) ApiCreateGroupRequest {
	r.P_groupCreateRequest = &groupCreateRequest
	return r
}

func (r ApiCreateGroupRequest) Execute() (Group, *_nethttp.Response, error) {
	return r.ApiService.CreateGroupExecute(r)
}

/*
 * CreateGroup Method for CreateGroup
 * group.write
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateGroupRequest
 */
func (a *GroupApiService) CreateGroup(Ctx _context.Context) ApiCreateGroupRequest {
	return ApiCreateGroupRequest{
		ApiService: a,
		Ctx: Ctx,
	}
}

/*
 * Execute executes the request
 * @return Group
 */
func (a *GroupApiService) CreateGroupExecute(r ApiCreateGroupRequest) (Group, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "GroupApiService.CreateGroup")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_groupCreateRequest == nil {
		return localVarReturnValue, nil, reportError("groupCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_groupCreateRequest
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteGroupRequest struct {
	Ctx _context.Context
	ApiService *GroupApiService
	P_groupId string
}


func (r ApiDeleteGroupRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteGroupExecute(r)
}

/*
 * DeleteGroup Method for DeleteGroup
 * group.write
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId
 * @return ApiDeleteGroupRequest
 */
func (a *GroupApiService) DeleteGroup(Ctx _context.Context, groupId string) ApiDeleteGroupRequest {
	return ApiDeleteGroupRequest{
		ApiService: a,
		Ctx: Ctx,
		P_groupId: groupId,
	}
}

/*
 * Execute executes the request
 */
func (a *GroupApiService) DeleteGroupExecute(r ApiDeleteGroupRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "GroupApiService.DeleteGroup")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/groups/{group_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group_id"+"}", _neturl.PathEscape(parameterToString(r.P_groupId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteMemberRequest struct {
	Ctx _context.Context
	ApiService *GroupApiService
	P_groupId string
	P_member *[]Member
}

func (r ApiDeleteMemberRequest) Member(member []Member) ApiDeleteMemberRequest {
	r.P_member = &member
	return r
}

func (r ApiDeleteMemberRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteMemberExecute(r)
}

/*
 * DeleteMember Method for DeleteMember
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId
 * @return ApiDeleteMemberRequest
 */
func (a *GroupApiService) DeleteMember(Ctx _context.Context, groupId string) ApiDeleteMemberRequest {
	return ApiDeleteMemberRequest{
		ApiService: a,
		Ctx: Ctx,
		P_groupId: groupId,
	}
}

/*
 * Execute executes the request
 */
func (a *GroupApiService) DeleteMemberExecute(r ApiDeleteMemberRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "GroupApiService.DeleteMember")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/groups/{group_id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"group_id"+"}", _neturl.PathEscape(parameterToString(r.P_groupId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_member == nil {
		return nil, reportError("member is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_member
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetGroupRequest struct {
	Ctx _context.Context
	ApiService *GroupApiService
	P_groupId string
	P_includes *string
}

func (r ApiGetGroupRequest) Includes(includes string) ApiGetGroupRequest {
	r.P_includes = &includes
	return r
}

func (r ApiGetGroupRequest) Execute() (Group, *_nethttp.Response, error) {
	return r.ApiService.GetGroupExecute(r)
}

/*
 * GetGroup Method for GetGroup
 * group.read
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId
 * @return ApiGetGroupRequest
 */
func (a *GroupApiService) GetGroup(Ctx _context.Context, groupId string) ApiGetGroupRequest {
	return ApiGetGroupRequest{
		ApiService: a,
		Ctx: Ctx,
		P_groupId: groupId,
	}
}

/*
 * Execute executes the request
 * @return Group
 */
func (a *GroupApiService) GetGroupExecute(r ApiGetGroupRequest) (Group, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "GroupApiService.GetGroup")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/groups/{group_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group_id"+"}", _neturl.PathEscape(parameterToString(r.P_groupId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.P_includes != nil {
		localVarQueryParams.Add("includes", parameterToString(*r.P_includes, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGroupsRequest struct {
	Ctx _context.Context
	ApiService *GroupApiService
	P_name *string
	P_parentGroupId *string
	P_state *string
	P_city *string
	P_address1 *string
	P_address2 *string
	P_type_ *string
	P_tags *string
	P_label *string
	P_domain *string
	P_offset *int64
	P_limit *int64
	P_orderBy *string
	P_order *string
	P_includes *string
	P_page *string
}

func (r ApiGetGroupsRequest) Name(name string) ApiGetGroupsRequest {
	r.P_name = &name
	return r
}
func (r ApiGetGroupsRequest) ParentGroupId(parentGroupId string) ApiGetGroupsRequest {
	r.P_parentGroupId = &parentGroupId
	return r
}
func (r ApiGetGroupsRequest) State(state string) ApiGetGroupsRequest {
	r.P_state = &state
	return r
}
func (r ApiGetGroupsRequest) City(city string) ApiGetGroupsRequest {
	r.P_city = &city
	return r
}
func (r ApiGetGroupsRequest) Address1(address1 string) ApiGetGroupsRequest {
	r.P_address1 = &address1
	return r
}
func (r ApiGetGroupsRequest) Address2(address2 string) ApiGetGroupsRequest {
	r.P_address2 = &address2
	return r
}
func (r ApiGetGroupsRequest) Type_(type_ string) ApiGetGroupsRequest {
	r.P_type_ = &type_
	return r
}
func (r ApiGetGroupsRequest) Tags(tags string) ApiGetGroupsRequest {
	r.P_tags = &tags
	return r
}
func (r ApiGetGroupsRequest) Label(label string) ApiGetGroupsRequest {
	r.P_label = &label
	return r
}
func (r ApiGetGroupsRequest) Domain(domain string) ApiGetGroupsRequest {
	r.P_domain = &domain
	return r
}
func (r ApiGetGroupsRequest) Offset(offset int64) ApiGetGroupsRequest {
	r.P_offset = &offset
	return r
}
func (r ApiGetGroupsRequest) Limit(limit int64) ApiGetGroupsRequest {
	r.P_limit = &limit
	return r
}
func (r ApiGetGroupsRequest) OrderBy(orderBy string) ApiGetGroupsRequest {
	r.P_orderBy = &orderBy
	return r
}
func (r ApiGetGroupsRequest) Order(order string) ApiGetGroupsRequest {
	r.P_order = &order
	return r
}
func (r ApiGetGroupsRequest) Includes(includes string) ApiGetGroupsRequest {
	r.P_includes = &includes
	return r
}
func (r ApiGetGroupsRequest) Page(page string) ApiGetGroupsRequest {
	r.P_page = &page
	return r
}

func (r ApiGetGroupsRequest) Execute() (MultipleGroup, *_nethttp.Response, error) {
	return r.ApiService.GetGroupsExecute(r)
}

/*
 * GetGroups Method for GetGroups
 * group.read
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetGroupsRequest
 */
func (a *GroupApiService) GetGroups(Ctx _context.Context) ApiGetGroupsRequest {
	return ApiGetGroupsRequest{
		ApiService: a,
		Ctx: Ctx,
	}
}

/*
 * Execute executes the request
 * @return MultipleGroup
 */
func (a *GroupApiService) GetGroupsExecute(r ApiGetGroupsRequest) (MultipleGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MultipleGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "GroupApiService.GetGroups")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.P_name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.P_name, ""))
	}
	if r.P_parentGroupId != nil {
		localVarQueryParams.Add("parent_group_id", parameterToString(*r.P_parentGroupId, ""))
	}
	if r.P_state != nil {
		localVarQueryParams.Add("state", parameterToString(*r.P_state, ""))
	}
	if r.P_city != nil {
		localVarQueryParams.Add("city", parameterToString(*r.P_city, ""))
	}
	if r.P_address1 != nil {
		localVarQueryParams.Add("address_1", parameterToString(*r.P_address1, ""))
	}
	if r.P_address2 != nil {
		localVarQueryParams.Add("address_2", parameterToString(*r.P_address2, ""))
	}
	if r.P_type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.P_type_, ""))
	}
	if r.P_tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.P_tags, ""))
	}
	if r.P_label != nil {
		localVarQueryParams.Add("label", parameterToString(*r.P_label, ""))
	}
	if r.P_domain != nil {
		localVarQueryParams.Add("domain", parameterToString(*r.P_domain, ""))
	}
	if r.P_offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.P_offset, ""))
	}
	if r.P_limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.P_limit, ""))
	}
	if r.P_orderBy != nil {
		localVarQueryParams.Add("order_by", parameterToString(*r.P_orderBy, ""))
	}
	if r.P_order != nil {
		localVarQueryParams.Add("order", parameterToString(*r.P_order, ""))
	}
	if r.P_includes != nil {
		localVarQueryParams.Add("includes", parameterToString(*r.P_includes, ""))
	}
	if r.P_page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.P_page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMembersRequest struct {
	Ctx _context.Context
	ApiService *GroupApiService
	P_groupId string
	P_userId *string
	P_name *string
	P_email *string
	P_primary *bool
	P_phoneticFamilyName *string
	P_phoneticGivenName *string
	P_role *string
	P_category *string
	P_tag *string
	P_includes *string
	P_page *string
	P_offset *int64
	P_limit *int64
	P_orderBy *string
	P_order *string
}

func (r ApiGetMembersRequest) UserId(userId string) ApiGetMembersRequest {
	r.P_userId = &userId
	return r
}
func (r ApiGetMembersRequest) Name(name string) ApiGetMembersRequest {
	r.P_name = &name
	return r
}
func (r ApiGetMembersRequest) Email(email string) ApiGetMembersRequest {
	r.P_email = &email
	return r
}
func (r ApiGetMembersRequest) Primary(primary bool) ApiGetMembersRequest {
	r.P_primary = &primary
	return r
}
func (r ApiGetMembersRequest) PhoneticFamilyName(phoneticFamilyName string) ApiGetMembersRequest {
	r.P_phoneticFamilyName = &phoneticFamilyName
	return r
}
func (r ApiGetMembersRequest) PhoneticGivenName(phoneticGivenName string) ApiGetMembersRequest {
	r.P_phoneticGivenName = &phoneticGivenName
	return r
}
func (r ApiGetMembersRequest) Role(role string) ApiGetMembersRequest {
	r.P_role = &role
	return r
}
func (r ApiGetMembersRequest) Category(category string) ApiGetMembersRequest {
	r.P_category = &category
	return r
}
func (r ApiGetMembersRequest) Tag(tag string) ApiGetMembersRequest {
	r.P_tag = &tag
	return r
}
func (r ApiGetMembersRequest) Includes(includes string) ApiGetMembersRequest {
	r.P_includes = &includes
	return r
}
func (r ApiGetMembersRequest) Page(page string) ApiGetMembersRequest {
	r.P_page = &page
	return r
}
func (r ApiGetMembersRequest) Offset(offset int64) ApiGetMembersRequest {
	r.P_offset = &offset
	return r
}
func (r ApiGetMembersRequest) Limit(limit int64) ApiGetMembersRequest {
	r.P_limit = &limit
	return r
}
func (r ApiGetMembersRequest) OrderBy(orderBy string) ApiGetMembersRequest {
	r.P_orderBy = &orderBy
	return r
}
func (r ApiGetMembersRequest) Order(order string) ApiGetMembersRequest {
	r.P_order = &order
	return r
}

func (r ApiGetMembersRequest) Execute() (MultipleMemberInfo, *_nethttp.Response, error) {
	return r.ApiService.GetMembersExecute(r)
}

/*
 * GetMembers Method for GetMembers
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId
 * @return ApiGetMembersRequest
 */
func (a *GroupApiService) GetMembers(Ctx _context.Context, groupId string) ApiGetMembersRequest {
	return ApiGetMembersRequest{
		ApiService: a,
		Ctx: Ctx,
		P_groupId: groupId,
	}
}

/*
 * Execute executes the request
 * @return MultipleMemberInfo
 */
func (a *GroupApiService) GetMembersExecute(r ApiGetMembersRequest) (MultipleMemberInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MultipleMemberInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "GroupApiService.GetMembers")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/groups/{group_id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"group_id"+"}", _neturl.PathEscape(parameterToString(r.P_groupId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.P_userId != nil {
		localVarQueryParams.Add("user_id", parameterToString(*r.P_userId, ""))
	}
	if r.P_name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.P_name, ""))
	}
	if r.P_email != nil {
		localVarQueryParams.Add("email", parameterToString(*r.P_email, ""))
	}
	if r.P_primary != nil {
		localVarQueryParams.Add("primary", parameterToString(*r.P_primary, ""))
	}
	if r.P_phoneticFamilyName != nil {
		localVarQueryParams.Add("phonetic_family_name", parameterToString(*r.P_phoneticFamilyName, ""))
	}
	if r.P_phoneticGivenName != nil {
		localVarQueryParams.Add("phonetic_given_name", parameterToString(*r.P_phoneticGivenName, ""))
	}
	if r.P_role != nil {
		localVarQueryParams.Add("role", parameterToString(*r.P_role, ""))
	}
	if r.P_category != nil {
		localVarQueryParams.Add("category", parameterToString(*r.P_category, ""))
	}
	if r.P_tag != nil {
		localVarQueryParams.Add("tag", parameterToString(*r.P_tag, ""))
	}
	if r.P_includes != nil {
		localVarQueryParams.Add("includes", parameterToString(*r.P_includes, ""))
	}
	if r.P_page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.P_page, ""))
	}
	if r.P_offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.P_offset, ""))
	}
	if r.P_limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.P_limit, ""))
	}
	if r.P_orderBy != nil {
		localVarQueryParams.Add("order_by", parameterToString(*r.P_orderBy, ""))
	}
	if r.P_order != nil {
		localVarQueryParams.Add("order", parameterToString(*r.P_order, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInviteGroupRequest struct {
	Ctx _context.Context
	ApiService *GroupApiService
	P_groupId string
	P_groupInviteRequest *GroupInviteRequest
}

func (r ApiInviteGroupRequest) GroupInviteRequest(groupInviteRequest GroupInviteRequest) ApiInviteGroupRequest {
	r.P_groupInviteRequest = &groupInviteRequest
	return r
}

func (r ApiInviteGroupRequest) Execute() (Member, *_nethttp.Response, error) {
	return r.ApiService.InviteGroupExecute(r)
}

/*
 * InviteGroup Method for InviteGroup
 * group.write
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId
 * @return ApiInviteGroupRequest
 */
func (a *GroupApiService) InviteGroup(Ctx _context.Context, groupId string) ApiInviteGroupRequest {
	return ApiInviteGroupRequest{
		ApiService: a,
		Ctx: Ctx,
		P_groupId: groupId,
	}
}

/*
 * Execute executes the request
 * @return Member
 */
func (a *GroupApiService) InviteGroupExecute(r ApiInviteGroupRequest) (Member, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Member
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "GroupApiService.InviteGroup")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/groups/{group_id}/invites"
	localVarPath = strings.Replace(localVarPath, "{"+"group_id"+"}", _neturl.PathEscape(parameterToString(r.P_groupId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_groupInviteRequest == nil {
		return localVarReturnValue, nil, reportError("groupInviteRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_groupInviteRequest
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceGroupRequest struct {
	Ctx _context.Context
	ApiService *GroupApiService
	P_groupId string
	P_groupReplaceRequest *GroupReplaceRequest
}

func (r ApiReplaceGroupRequest) GroupReplaceRequest(groupReplaceRequest GroupReplaceRequest) ApiReplaceGroupRequest {
	r.P_groupReplaceRequest = &groupReplaceRequest
	return r
}

func (r ApiReplaceGroupRequest) Execute() (Group, *_nethttp.Response, error) {
	return r.ApiService.ReplaceGroupExecute(r)
}

/*
 * ReplaceGroup Method for ReplaceGroup
 * group.write
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId
 * @return ApiReplaceGroupRequest
 */
func (a *GroupApiService) ReplaceGroup(Ctx _context.Context, groupId string) ApiReplaceGroupRequest {
	return ApiReplaceGroupRequest{
		ApiService: a,
		Ctx: Ctx,
		P_groupId: groupId,
	}
}

/*
 * Execute executes the request
 * @return Group
 */
func (a *GroupApiService) ReplaceGroupExecute(r ApiReplaceGroupRequest) (Group, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "GroupApiService.ReplaceGroup")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/groups/{group_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group_id"+"}", _neturl.PathEscape(parameterToString(r.P_groupId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_groupReplaceRequest == nil {
		return localVarReturnValue, nil, reportError("groupReplaceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_groupReplaceRequest
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetMemberRequest struct {
	Ctx _context.Context
	ApiService *GroupApiService
	P_groupId string
	P_member *Member
}

func (r ApiSetMemberRequest) Member(member Member) ApiSetMemberRequest {
	r.P_member = &member
	return r
}

func (r ApiSetMemberRequest) Execute() (Member, *_nethttp.Response, error) {
	return r.ApiService.SetMemberExecute(r)
}

/*
 * SetMember Method for SetMember
 * group.write
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId
 * @return ApiSetMemberRequest
 */
func (a *GroupApiService) SetMember(Ctx _context.Context, groupId string) ApiSetMemberRequest {
	return ApiSetMemberRequest{
		ApiService: a,
		Ctx: Ctx,
		P_groupId: groupId,
	}
}

/*
 * Execute executes the request
 * @return Member
 */
func (a *GroupApiService) SetMemberExecute(r ApiSetMemberRequest) (Member, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Member
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "GroupApiService.SetMember")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/groups/{group_id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"group_id"+"}", _neturl.PathEscape(parameterToString(r.P_groupId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_member == nil {
		return localVarReturnValue, nil, reportError("member is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_member
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateGroupRequest struct {
	Ctx _context.Context
	ApiService *GroupApiService
	P_groupId string
	P_groupUpdateRequest *GroupUpdateRequest
}

func (r ApiUpdateGroupRequest) GroupUpdateRequest(groupUpdateRequest GroupUpdateRequest) ApiUpdateGroupRequest {
	r.P_groupUpdateRequest = &groupUpdateRequest
	return r
}

func (r ApiUpdateGroupRequest) Execute() (Group, *_nethttp.Response, error) {
	return r.ApiService.UpdateGroupExecute(r)
}

/*
 * UpdateGroup Method for UpdateGroup
 * group.write
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId
 * @return ApiUpdateGroupRequest
 */
func (a *GroupApiService) UpdateGroup(Ctx _context.Context, groupId string) ApiUpdateGroupRequest {
	return ApiUpdateGroupRequest{
		ApiService: a,
		Ctx: Ctx,
		P_groupId: groupId,
	}
}

/*
 * Execute executes the request
 * @return Group
 */
func (a *GroupApiService) UpdateGroupExecute(r ApiUpdateGroupRequest) (Group, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "GroupApiService.UpdateGroup")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/groups/{group_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group_id"+"}", _neturl.PathEscape(parameterToString(r.P_groupId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_groupUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("groupUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_groupUpdateRequest
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateMemberRequest struct {
	Ctx _context.Context
	ApiService *GroupApiService
	P_groupId string
	P_multipleMember *MultipleMember
}

func (r ApiUpdateMemberRequest) MultipleMember(multipleMember MultipleMember) ApiUpdateMemberRequest {
	r.P_multipleMember = &multipleMember
	return r
}

func (r ApiUpdateMemberRequest) Execute() (MultipleMember, *_nethttp.Response, error) {
	return r.ApiService.UpdateMemberExecute(r)
}

/*
 * UpdateMember Method for UpdateMember
 * group.write
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId
 * @return ApiUpdateMemberRequest
 */
func (a *GroupApiService) UpdateMember(Ctx _context.Context, groupId string) ApiUpdateMemberRequest {
	return ApiUpdateMemberRequest{
		ApiService: a,
		Ctx: Ctx,
		P_groupId: groupId,
	}
}

/*
 * Execute executes the request
 * @return MultipleMember
 */
func (a *GroupApiService) UpdateMemberExecute(r ApiUpdateMemberRequest) (MultipleMember, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MultipleMember
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "GroupApiService.UpdateMember")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/groups/{group_id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"group_id"+"}", _neturl.PathEscape(parameterToString(r.P_groupId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_multipleMember == nil {
		return localVarReturnValue, nil, reportError("multipleMember is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_multipleMember
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
