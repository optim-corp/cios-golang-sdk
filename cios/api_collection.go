/*
 * Cios Openapi
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.1
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cios

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// CollectionApiService CollectionApi service
type CollectionApiService service

type ApiCreateSeriesDataBulkRequest struct {
	Ctx _context.Context
	ApiService *CollectionApiService
	P_collectionId string
	P_seriesId string
	P_seriesDataBulkRequest *SeriesDataBulkRequest
	P_resourceOwnerId *string
}

func (r ApiCreateSeriesDataBulkRequest) SeriesDataBulkRequest(seriesDataBulkRequest SeriesDataBulkRequest) ApiCreateSeriesDataBulkRequest {
	r.P_seriesDataBulkRequest = &seriesDataBulkRequest
	return r
}
func (r ApiCreateSeriesDataBulkRequest) ResourceOwnerId(resourceOwnerId string) ApiCreateSeriesDataBulkRequest {
	r.P_resourceOwnerId = &resourceOwnerId
	return r
}

func (r ApiCreateSeriesDataBulkRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CreateSeriesDataBulkExecute(r)
}

/*
 * CreateSeriesDataBulk Method for CreateSeriesDataBulk
 * 複数のデータの保存、時系列データ存在確認への反映は非同期

Supported application type：Web, Native, Client, Device
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param collectionId コレクション名
 * @param seriesId シリーズID
 * @return ApiCreateSeriesDataBulkRequest
 */
func (a *CollectionApiService) CreateSeriesDataBulk(Ctx _context.Context, collectionId string, seriesId string) ApiCreateSeriesDataBulkRequest {
	return ApiCreateSeriesDataBulkRequest{
		ApiService: a,
		Ctx: Ctx,
		P_collectionId: collectionId,
		P_seriesId: seriesId,
	}
}

/*
 * Execute executes the request
 */
func (a *CollectionApiService) CreateSeriesDataBulkExecute(r ApiCreateSeriesDataBulkRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "CollectionApiService.CreateSeriesDataBulk")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/collections/{collection_id}/series/{series_id}/data-bulk"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", _neturl.PathEscape(parameterToString(r.P_collectionId, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"series_id"+"}", _neturl.PathEscape(parameterToString(r.P_seriesId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_seriesDataBulkRequest == nil {
		return nil, reportError("seriesDataBulkRequest is required and must be specified")
	}

	if r.P_resourceOwnerId != nil {
		localVarQueryParams.Add("resource_owner_id", parameterToString(*r.P_resourceOwnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_seriesDataBulkRequest
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateSeriesImageRequest struct {
	Ctx _context.Context
	ApiService *CollectionApiService
	P_collectionId string
	P_seriesId string
	P_timestamp int64
	P_body *string
	P_resourceOwnerId *string
	P_isLatest *bool
}

func (r ApiCreateSeriesImageRequest) Body(body string) ApiCreateSeriesImageRequest {
	r.P_body = &body
	return r
}
func (r ApiCreateSeriesImageRequest) ResourceOwnerId(resourceOwnerId string) ApiCreateSeriesImageRequest {
	r.P_resourceOwnerId = &resourceOwnerId
	return r
}
func (r ApiCreateSeriesImageRequest) IsLatest(isLatest bool) ApiCreateSeriesImageRequest {
	r.P_isLatest = &isLatest
	return r
}

func (r ApiCreateSeriesImageRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CreateSeriesImageExecute(r)
}

/*
 * CreateSeriesImage Method for CreateSeriesImage
 * 画像を保存する。

レスポンスのhttpステータスが500となった場合、最新オリジナル画像、最新サムネイル画像、
オリジナル画像履歴、サムネイル画像履歴のうち一部だけが保存完了している可能性がある。
その場合は保存が完了した画像だけが画像取得APIで取得される状態となるが、
同じタイムスタンプで再度画像をアップロードすることで、それらの画像を上書きすることができる。

Supported application type: Web, Native, Client, Device
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param collectionId コレクション名
 * @param seriesId シリーズID
 * @param timestamp UNIXタイム(ミリ秒)
 * @return ApiCreateSeriesImageRequest
 */
func (a *CollectionApiService) CreateSeriesImage(Ctx _context.Context, collectionId string, seriesId string, timestamp int64) ApiCreateSeriesImageRequest {
	return ApiCreateSeriesImageRequest{
		ApiService: a,
		Ctx: Ctx,
		P_collectionId: collectionId,
		P_seriesId: seriesId,
		P_timestamp: timestamp,
	}
}

/*
 * Execute executes the request
 */
func (a *CollectionApiService) CreateSeriesImageExecute(r ApiCreateSeriesImageRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "CollectionApiService.CreateSeriesImage")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/collections/{collection_id}/series/{series_id}/timestamp/{timestamp}/image"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", _neturl.PathEscape(parameterToString(r.P_collectionId, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"series_id"+"}", _neturl.PathEscape(parameterToString(r.P_seriesId, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"timestamp"+"}", _neturl.PathEscape(parameterToString(r.P_timestamp, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.P_resourceOwnerId != nil {
		localVarQueryParams.Add("resource_owner_id", parameterToString(*r.P_resourceOwnerId, ""))
	}
	if r.P_isLatest != nil {
		localVarQueryParams.Add("is_latest", parameterToString(*r.P_isLatest, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"image/jpeg", "image/png"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_body
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSeriesLatestRequest struct {
	Ctx _context.Context
	ApiService *CollectionApiService
	P_collectionId string
	P_seriesId string
	P_timestamp int64
	P_resourceOwnerId *string
}

func (r ApiDeleteSeriesLatestRequest) ResourceOwnerId(resourceOwnerId string) ApiDeleteSeriesLatestRequest {
	r.P_resourceOwnerId = &resourceOwnerId
	return r
}

func (r ApiDeleteSeriesLatestRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteSeriesLatestExecute(r)
}

/*
 * DeleteSeriesLatest Method for DeleteSeriesLatest
 * シリーズIDを指定して最新データを削除する。削除後は当該シリーズの最新データおよび画像は最新データ取得APIのレスポンスに含まれない。<br>
Responseが500の場合、最新データまたは最新画像のいずれかが残っている可能性がある。<br>
再度APIを実行してResponseが204であれば残ったリソースも削除できた状態となる。

Supported application type:Web, Native, Client, Device
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param collectionId コレクション名
 * @param seriesId シリーズID
 * @param timestamp UNIXタイム(ミリ秒)
 * @return ApiDeleteSeriesLatestRequest
 */
func (a *CollectionApiService) DeleteSeriesLatest(Ctx _context.Context, collectionId string, seriesId string, timestamp int64) ApiDeleteSeriesLatestRequest {
	return ApiDeleteSeriesLatestRequest{
		ApiService: a,
		Ctx: Ctx,
		P_collectionId: collectionId,
		P_seriesId: seriesId,
		P_timestamp: timestamp,
	}
}

/*
 * Execute executes the request
 */
func (a *CollectionApiService) DeleteSeriesLatestExecute(r ApiDeleteSeriesLatestRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "CollectionApiService.DeleteSeriesLatest")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/collections/{collection_id}/series/{series_id}/latest"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", _neturl.PathEscape(parameterToString(r.P_collectionId, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"series_id"+"}", _neturl.PathEscape(parameterToString(r.P_seriesId, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"timestamp"+"}", _neturl.PathEscape(parameterToString(r.P_timestamp, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.P_resourceOwnerId != nil {
		localVarQueryParams.Add("resource_owner_id", parameterToString(*r.P_resourceOwnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetCollectionStatusRequest struct {
	Ctx _context.Context
	ApiService *CollectionApiService
	P_collectionId string
	P_resourceOwnerId *string
}

func (r ApiGetCollectionStatusRequest) ResourceOwnerId(resourceOwnerId string) ApiGetCollectionStatusRequest {
	r.P_resourceOwnerId = &resourceOwnerId
	return r
}

func (r ApiGetCollectionStatusRequest) Execute() (interface{}, *_nethttp.Response, error) {
	return r.ApiService.GetCollectionStatusExecute(r)
}

/*
 * GetCollectionStatus Method for GetCollectionStatus
 * アーカイブ・リストア状態を取得する。

アーカイブ・リストア状態遷移
![](./images/archive-restore-state-transtition-diagram.png)

Supported application type：Web, Native
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param collectionId コレクション名
 * @return ApiGetCollectionStatusRequest
 */
func (a *CollectionApiService) GetCollectionStatus(Ctx _context.Context, collectionId string) ApiGetCollectionStatusRequest {
	return ApiGetCollectionStatusRequest{
		ApiService: a,
		Ctx: Ctx,
		P_collectionId: collectionId,
	}
}

/*
 * Execute executes the request
 * @return interface{}
 */
func (a *CollectionApiService) GetCollectionStatusExecute(r ApiGetCollectionStatusRequest) (interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "CollectionApiService.GetCollectionStatus")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/collections/{collection_id}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", _neturl.PathEscape(parameterToString(r.P_collectionId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.P_resourceOwnerId != nil {
		localVarQueryParams.Add("resource_owner_id", parameterToString(*r.P_resourceOwnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRecordedDatesRequest struct {
	Ctx _context.Context
	ApiService *CollectionApiService
	P_collectionId string
	P_month *string
	P_resourceOwnerId *string
	P_gmtOffset *string
}

func (r ApiGetRecordedDatesRequest) Month(month string) ApiGetRecordedDatesRequest {
	r.P_month = &month
	return r
}
func (r ApiGetRecordedDatesRequest) ResourceOwnerId(resourceOwnerId string) ApiGetRecordedDatesRequest {
	r.P_resourceOwnerId = &resourceOwnerId
	return r
}
func (r ApiGetRecordedDatesRequest) GmtOffset(gmtOffset string) ApiGetRecordedDatesRequest {
	r.P_gmtOffset = &gmtOffset
	return r
}

func (r ApiGetRecordedDatesRequest) Execute() (RecordedDates, *_nethttp.Response, error) {
	return r.ApiService.GetRecordedDatesExecute(r)
}

/*
 * GetRecordedDates Method for GetRecordedDates
 * 指定した年月において、時系列データが存在する日付のリストを取得する。

時系列データ保存API、または、時系列データ保存(bulk upload)APIで保存された時系列データが存在する日付のみ取得対象であり、画像のみが存在する日付は取得されない。

Supported application type:Web, Native, Client
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param collectionId コレクション名
 * @return ApiGetRecordedDatesRequest
 */
func (a *CollectionApiService) GetRecordedDates(Ctx _context.Context, collectionId string) ApiGetRecordedDatesRequest {
	return ApiGetRecordedDatesRequest{
		ApiService: a,
		Ctx: Ctx,
		P_collectionId: collectionId,
	}
}

/*
 * Execute executes the request
 * @return RecordedDates
 */
func (a *CollectionApiService) GetRecordedDatesExecute(r ApiGetRecordedDatesRequest) (RecordedDates, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RecordedDates
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "CollectionApiService.GetRecordedDates")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/collections/{collection_id}/recorded-dates"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", _neturl.PathEscape(parameterToString(r.P_collectionId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_month == nil {
		return localVarReturnValue, nil, reportError("month is required and must be specified")
	}

	if r.P_resourceOwnerId != nil {
		localVarQueryParams.Add("resource_owner_id", parameterToString(*r.P_resourceOwnerId, ""))
	}
	localVarQueryParams.Add("month", parameterToString(*r.P_month, ""))
	if r.P_gmtOffset != nil {
		localVarQueryParams.Add("gmt_offset", parameterToString(*r.P_gmtOffset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSeriesRequest struct {
	Ctx _context.Context
	ApiService *CollectionApiService
	P_collectionId string
	P_seriesId string
	P_timeRange *string
	P_resourceOwnerId *string
	P_acceptEncoding *string
	P_limit *int64
	P_offset *int64
	P_ascending *bool
}

func (r ApiGetSeriesRequest) TimeRange(timeRange string) ApiGetSeriesRequest {
	r.P_timeRange = &timeRange
	return r
}
func (r ApiGetSeriesRequest) ResourceOwnerId(resourceOwnerId string) ApiGetSeriesRequest {
	r.P_resourceOwnerId = &resourceOwnerId
	return r
}
func (r ApiGetSeriesRequest) AcceptEncoding(acceptEncoding string) ApiGetSeriesRequest {
	r.P_acceptEncoding = &acceptEncoding
	return r
}
func (r ApiGetSeriesRequest) Limit(limit int64) ApiGetSeriesRequest {
	r.P_limit = &limit
	return r
}
func (r ApiGetSeriesRequest) Offset(offset int64) ApiGetSeriesRequest {
	r.P_offset = &offset
	return r
}
func (r ApiGetSeriesRequest) Ascending(ascending bool) ApiGetSeriesRequest {
	r.P_ascending = &ascending
	return r
}

func (r ApiGetSeriesRequest) Execute() (MultipleSeriesDataLocationUnix, *_nethttp.Response, error) {
	return r.ApiService.GetSeriesExecute(r)
}

/*
 * GetSeries Method for GetSeries
 * 期間・シリーズID等を指定して時系列データを取得する。

Supported application type:Web, Native, Client
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param collectionId コレクション名
 * @param seriesId シリーズID
 * @return ApiGetSeriesRequest
 */
func (a *CollectionApiService) GetSeries(Ctx _context.Context, collectionId string, seriesId string) ApiGetSeriesRequest {
	return ApiGetSeriesRequest{
		ApiService: a,
		Ctx: Ctx,
		P_collectionId: collectionId,
		P_seriesId: seriesId,
	}
}

/*
 * Execute executes the request
 * @return MultipleSeriesDataLocationUnix
 */
func (a *CollectionApiService) GetSeriesExecute(r ApiGetSeriesRequest) (MultipleSeriesDataLocationUnix, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MultipleSeriesDataLocationUnix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "CollectionApiService.GetSeries")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/collections/{collection_id}/series/{series_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", _neturl.PathEscape(parameterToString(r.P_collectionId, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"series_id"+"}", _neturl.PathEscape(parameterToString(r.P_seriesId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_timeRange == nil {
		return localVarReturnValue, nil, reportError("timeRange is required and must be specified")
	}

	if r.P_resourceOwnerId != nil {
		localVarQueryParams.Add("resource_owner_id", parameterToString(*r.P_resourceOwnerId, ""))
	}
	localVarQueryParams.Add("time_range", parameterToString(*r.P_timeRange, ""))
	if r.P_limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.P_limit, ""))
	}
	if r.P_offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.P_offset, ""))
	}
	if r.P_ascending != nil {
		localVarQueryParams.Add("ascending", parameterToString(*r.P_ascending, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.P_acceptEncoding != nil {
		localVarHeaderParams["Accept-Encoding"] = parameterToString(*r.P_acceptEncoding, "")
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSeriesAggregationRequest struct {
	Ctx _context.Context
	ApiService *CollectionApiService
	P_collectionId string
	P_seriesId string
	P_timeRange *string
	P_interval *int32
	P_requestBody *[]map[string]interface{}
	P_resourceOwnerId *string
	P_acceptEncoding *string
	P_ascending *bool
}

func (r ApiGetSeriesAggregationRequest) TimeRange(timeRange string) ApiGetSeriesAggregationRequest {
	r.P_timeRange = &timeRange
	return r
}
func (r ApiGetSeriesAggregationRequest) Interval(interval int32) ApiGetSeriesAggregationRequest {
	r.P_interval = &interval
	return r
}
func (r ApiGetSeriesAggregationRequest) RequestBody(requestBody []map[string]interface{}) ApiGetSeriesAggregationRequest {
	r.P_requestBody = &requestBody
	return r
}
func (r ApiGetSeriesAggregationRequest) ResourceOwnerId(resourceOwnerId string) ApiGetSeriesAggregationRequest {
	r.P_resourceOwnerId = &resourceOwnerId
	return r
}
func (r ApiGetSeriesAggregationRequest) AcceptEncoding(acceptEncoding string) ApiGetSeriesAggregationRequest {
	r.P_acceptEncoding = &acceptEncoding
	return r
}
func (r ApiGetSeriesAggregationRequest) Ascending(ascending bool) ApiGetSeriesAggregationRequest {
	r.P_ascending = &ascending
	return r
}

func (r ApiGetSeriesAggregationRequest) Execute() (SeriesAggregations, *_nethttp.Response, error) {
	return r.ApiService.GetSeriesAggregationExecute(r)
}

/*
 * GetSeriesAggregation Method for GetSeriesAggregation
 * 期間・シリーズID等を指定して時系列データの計測値を集計する。

Supported application type:Web, Native, Client
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param collectionId コレクション名
 * @param seriesId シリーズID
 * @return ApiGetSeriesAggregationRequest
 */
func (a *CollectionApiService) GetSeriesAggregation(Ctx _context.Context, collectionId string, seriesId string) ApiGetSeriesAggregationRequest {
	return ApiGetSeriesAggregationRequest{
		ApiService: a,
		Ctx: Ctx,
		P_collectionId: collectionId,
		P_seriesId: seriesId,
	}
}

/*
 * Execute executes the request
 * @return SeriesAggregations
 */
func (a *CollectionApiService) GetSeriesAggregationExecute(r ApiGetSeriesAggregationRequest) (SeriesAggregations, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SeriesAggregations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "CollectionApiService.GetSeriesAggregation")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/collections/{collection_id}/series/{series_id}/aggregation"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", _neturl.PathEscape(parameterToString(r.P_collectionId, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"series_id"+"}", _neturl.PathEscape(parameterToString(r.P_seriesId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_timeRange == nil {
		return localVarReturnValue, nil, reportError("timeRange is required and must be specified")
	}
	if r.P_interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}
	if *r.P_interval < 1000 {
		return localVarReturnValue, nil, reportError("interval must be greater than 1000")
	}
	if *r.P_interval > 86400000 {
		return localVarReturnValue, nil, reportError("interval must be less than 86400000")
	}
	if r.P_requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	if r.P_resourceOwnerId != nil {
		localVarQueryParams.Add("resource_owner_id", parameterToString(*r.P_resourceOwnerId, ""))
	}
	localVarQueryParams.Add("time_range", parameterToString(*r.P_timeRange, ""))
	localVarQueryParams.Add("interval", parameterToString(*r.P_interval, ""))
	if r.P_ascending != nil {
		localVarQueryParams.Add("ascending", parameterToString(*r.P_ascending, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.P_acceptEncoding != nil {
		localVarHeaderParams["Accept-Encoding"] = parameterToString(*r.P_acceptEncoding, "")
	}
	// body params
	localVarPostBody = r.P_requestBody
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSeriesImageRequest struct {
	Ctx _context.Context
	ApiService *CollectionApiService
	P_collectionId string
	P_seriesId string
	P_timestamp int64
	P_seriesDataBulkRequest *SeriesDataBulkRequest
	P_resourceOwnerId *string
}

func (r ApiGetSeriesImageRequest) SeriesDataBulkRequest(seriesDataBulkRequest SeriesDataBulkRequest) ApiGetSeriesImageRequest {
	r.P_seriesDataBulkRequest = &seriesDataBulkRequest
	return r
}
func (r ApiGetSeriesImageRequest) ResourceOwnerId(resourceOwnerId string) ApiGetSeriesImageRequest {
	r.P_resourceOwnerId = &resourceOwnerId
	return r
}

func (r ApiGetSeriesImageRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.GetSeriesImageExecute(r)
}

/*
 * GetSeriesImage Method for GetSeriesImage
 * シリーズID、時刻を指定してオリジナル画像を取得する。

Supported application type:Web, Native, Client
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param collectionId コレクション名
 * @param seriesId シリーズID
 * @param timestamp UNIXタイム(ミリ秒)
 * @return ApiGetSeriesImageRequest
 */
func (a *CollectionApiService) GetSeriesImage(Ctx _context.Context, collectionId string, seriesId string, timestamp int64) ApiGetSeriesImageRequest {
	return ApiGetSeriesImageRequest{
		ApiService: a,
		Ctx: Ctx,
		P_collectionId: collectionId,
		P_seriesId: seriesId,
		P_timestamp: timestamp,
	}
}

/*
 * Execute executes the request
 * @return string
 */
func (a *CollectionApiService) GetSeriesImageExecute(r ApiGetSeriesImageRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "CollectionApiService.GetSeriesImage")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/collections/{collection_id}/series/{series_id}/timestamp/{timestamp}/image"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", _neturl.PathEscape(parameterToString(r.P_collectionId, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"series_id"+"}", _neturl.PathEscape(parameterToString(r.P_seriesId, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"timestamp"+"}", _neturl.PathEscape(parameterToString(r.P_timestamp, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_seriesDataBulkRequest == nil {
		return localVarReturnValue, nil, reportError("seriesDataBulkRequest is required and must be specified")
	}

	if r.P_resourceOwnerId != nil {
		localVarQueryParams.Add("resource_owner_id", parameterToString(*r.P_resourceOwnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/jpeg", "image/png"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_seriesDataBulkRequest
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSeriesImagesRequest struct {
	Ctx _context.Context
	ApiService *CollectionApiService
	P_collectionId string
	P_seriesId string
	P_timeRange *string
	P_resourceOwnerId *string
	P_acceptEncoding *string
	P_limit *int64
	P_offset *int64
	P_ascending *bool
}

func (r ApiGetSeriesImagesRequest) TimeRange(timeRange string) ApiGetSeriesImagesRequest {
	r.P_timeRange = &timeRange
	return r
}
func (r ApiGetSeriesImagesRequest) ResourceOwnerId(resourceOwnerId string) ApiGetSeriesImagesRequest {
	r.P_resourceOwnerId = &resourceOwnerId
	return r
}
func (r ApiGetSeriesImagesRequest) AcceptEncoding(acceptEncoding string) ApiGetSeriesImagesRequest {
	r.P_acceptEncoding = &acceptEncoding
	return r
}
func (r ApiGetSeriesImagesRequest) Limit(limit int64) ApiGetSeriesImagesRequest {
	r.P_limit = &limit
	return r
}
func (r ApiGetSeriesImagesRequest) Offset(offset int64) ApiGetSeriesImagesRequest {
	r.P_offset = &offset
	return r
}
func (r ApiGetSeriesImagesRequest) Ascending(ascending bool) ApiGetSeriesImagesRequest {
	r.P_ascending = &ascending
	return r
}

func (r ApiGetSeriesImagesRequest) Execute() (MultipleSeriesImage, *_nethttp.Response, error) {
	return r.ApiService.GetSeriesImagesExecute(r)
}

/*
 * GetSeriesImages Method for GetSeriesImages
 * シリーズID、期間等を指定してオリジナル画像の履歴を取得する。

Supported application type:Web, Native, Client
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param collectionId コレクション名
 * @param seriesId シリーズID
 * @return ApiGetSeriesImagesRequest
 */
func (a *CollectionApiService) GetSeriesImages(Ctx _context.Context, collectionId string, seriesId string) ApiGetSeriesImagesRequest {
	return ApiGetSeriesImagesRequest{
		ApiService: a,
		Ctx: Ctx,
		P_collectionId: collectionId,
		P_seriesId: seriesId,
	}
}

/*
 * Execute executes the request
 * @return MultipleSeriesImage
 */
func (a *CollectionApiService) GetSeriesImagesExecute(r ApiGetSeriesImagesRequest) (MultipleSeriesImage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MultipleSeriesImage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "CollectionApiService.GetSeriesImages")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/collections/{collection_id}/series/{series_id}/images"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", _neturl.PathEscape(parameterToString(r.P_collectionId, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"series_id"+"}", _neturl.PathEscape(parameterToString(r.P_seriesId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_timeRange == nil {
		return localVarReturnValue, nil, reportError("timeRange is required and must be specified")
	}

	if r.P_resourceOwnerId != nil {
		localVarQueryParams.Add("resource_owner_id", parameterToString(*r.P_resourceOwnerId, ""))
	}
	localVarQueryParams.Add("time_range", parameterToString(*r.P_timeRange, ""))
	if r.P_limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.P_limit, ""))
	}
	if r.P_offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.P_offset, ""))
	}
	if r.P_ascending != nil {
		localVarQueryParams.Add("ascending", parameterToString(*r.P_ascending, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.P_acceptEncoding != nil {
		localVarHeaderParams["Accept-Encoding"] = parameterToString(*r.P_acceptEncoding, "")
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSeriesThumbnailsRequest struct {
	Ctx _context.Context
	ApiService *CollectionApiService
	P_collectionId string
	P_seriesId string
	P_timeRange *string
	P_resourceOwnerId *string
	P_acceptEncoding *string
	P_limit *int64
	P_offset *int64
	P_ascending *bool
}

func (r ApiGetSeriesThumbnailsRequest) TimeRange(timeRange string) ApiGetSeriesThumbnailsRequest {
	r.P_timeRange = &timeRange
	return r
}
func (r ApiGetSeriesThumbnailsRequest) ResourceOwnerId(resourceOwnerId string) ApiGetSeriesThumbnailsRequest {
	r.P_resourceOwnerId = &resourceOwnerId
	return r
}
func (r ApiGetSeriesThumbnailsRequest) AcceptEncoding(acceptEncoding string) ApiGetSeriesThumbnailsRequest {
	r.P_acceptEncoding = &acceptEncoding
	return r
}
func (r ApiGetSeriesThumbnailsRequest) Limit(limit int64) ApiGetSeriesThumbnailsRequest {
	r.P_limit = &limit
	return r
}
func (r ApiGetSeriesThumbnailsRequest) Offset(offset int64) ApiGetSeriesThumbnailsRequest {
	r.P_offset = &offset
	return r
}
func (r ApiGetSeriesThumbnailsRequest) Ascending(ascending bool) ApiGetSeriesThumbnailsRequest {
	r.P_ascending = &ascending
	return r
}

func (r ApiGetSeriesThumbnailsRequest) Execute() (MultipleSeriesImage, *_nethttp.Response, error) {
	return r.ApiService.GetSeriesThumbnailsExecute(r)
}

/*
 * GetSeriesThumbnails Method for GetSeriesThumbnails
 * シリーズID、期間等を指定してサムネイル画像の履歴を取得する。

Supported application type:Web, Native, Client
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param collectionId コレクション名
 * @param seriesId シリーズID
 * @return ApiGetSeriesThumbnailsRequest
 */
func (a *CollectionApiService) GetSeriesThumbnails(Ctx _context.Context, collectionId string, seriesId string) ApiGetSeriesThumbnailsRequest {
	return ApiGetSeriesThumbnailsRequest{
		ApiService: a,
		Ctx: Ctx,
		P_collectionId: collectionId,
		P_seriesId: seriesId,
	}
}

/*
 * Execute executes the request
 * @return MultipleSeriesImage
 */
func (a *CollectionApiService) GetSeriesThumbnailsExecute(r ApiGetSeriesThumbnailsRequest) (MultipleSeriesImage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MultipleSeriesImage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "CollectionApiService.GetSeriesThumbnails")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/collections/{collection_id}/series/{series_id}/thumbnails"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", _neturl.PathEscape(parameterToString(r.P_collectionId, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"series_id"+"}", _neturl.PathEscape(parameterToString(r.P_seriesId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_timeRange == nil {
		return localVarReturnValue, nil, reportError("timeRange is required and must be specified")
	}

	if r.P_resourceOwnerId != nil {
		localVarQueryParams.Add("resource_owner_id", parameterToString(*r.P_resourceOwnerId, ""))
	}
	localVarQueryParams.Add("time_range", parameterToString(*r.P_timeRange, ""))
	if r.P_limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.P_limit, ""))
	}
	if r.P_offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.P_offset, ""))
	}
	if r.P_ascending != nil {
		localVarQueryParams.Add("ascending", parameterToString(*r.P_ascending, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.P_acceptEncoding != nil {
		localVarHeaderParams["Accept-Encoding"] = parameterToString(*r.P_acceptEncoding, "")
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSeriesThumnbnailRequest struct {
	Ctx _context.Context
	ApiService *CollectionApiService
	P_collectionId string
	P_seriesId string
	P_timestamp int64
	P_seriesDataBulkRequest *SeriesDataBulkRequest
	P_resourceOwnerId *string
}

func (r ApiGetSeriesThumnbnailRequest) SeriesDataBulkRequest(seriesDataBulkRequest SeriesDataBulkRequest) ApiGetSeriesThumnbnailRequest {
	r.P_seriesDataBulkRequest = &seriesDataBulkRequest
	return r
}
func (r ApiGetSeriesThumnbnailRequest) ResourceOwnerId(resourceOwnerId string) ApiGetSeriesThumnbnailRequest {
	r.P_resourceOwnerId = &resourceOwnerId
	return r
}

func (r ApiGetSeriesThumnbnailRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.GetSeriesThumnbnailExecute(r)
}

/*
 * GetSeriesThumnbnail Method for GetSeriesThumnbnail
 * シリーズID、時刻を指定してサムネイル画像を取得する。

Supported application type:Web, Native, Client
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param collectionId コレクション名
 * @param seriesId シリーズID
 * @param timestamp UNIXタイム(ミリ秒)
 * @return ApiGetSeriesThumnbnailRequest
 */
func (a *CollectionApiService) GetSeriesThumnbnail(Ctx _context.Context, collectionId string, seriesId string, timestamp int64) ApiGetSeriesThumnbnailRequest {
	return ApiGetSeriesThumnbnailRequest{
		ApiService: a,
		Ctx: Ctx,
		P_collectionId: collectionId,
		P_seriesId: seriesId,
		P_timestamp: timestamp,
	}
}

/*
 * Execute executes the request
 * @return string
 */
func (a *CollectionApiService) GetSeriesThumnbnailExecute(r ApiGetSeriesThumnbnailRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "CollectionApiService.GetSeriesThumnbnail")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/collections/{collection_id}/series/{series_id}/timestamp/{timestamp}/thumbnail"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", _neturl.PathEscape(parameterToString(r.P_collectionId, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"series_id"+"}", _neturl.PathEscape(parameterToString(r.P_seriesId, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"timestamp"+"}", _neturl.PathEscape(parameterToString(r.P_timestamp, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_seriesDataBulkRequest == nil {
		return localVarReturnValue, nil, reportError("seriesDataBulkRequest is required and must be specified")
	}

	if r.P_resourceOwnerId != nil {
		localVarQueryParams.Add("resource_owner_id", parameterToString(*r.P_resourceOwnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/jpeg", "image/png"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_seriesDataBulkRequest
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesDataRequest struct {
	Ctx _context.Context
	ApiService *CollectionApiService
	P_collectionId string
	P_seriesId string
	P_timeRange *string
	P_resourceOwnerId *string
	P_acceptEncoding *string
	P_limit *int64
	P_offset *int64
	P_ascending *bool
}

func (r ApiGetTimeSeriesDataRequest) TimeRange(timeRange string) ApiGetTimeSeriesDataRequest {
	r.P_timeRange = &timeRange
	return r
}
func (r ApiGetTimeSeriesDataRequest) ResourceOwnerId(resourceOwnerId string) ApiGetTimeSeriesDataRequest {
	r.P_resourceOwnerId = &resourceOwnerId
	return r
}
func (r ApiGetTimeSeriesDataRequest) AcceptEncoding(acceptEncoding string) ApiGetTimeSeriesDataRequest {
	r.P_acceptEncoding = &acceptEncoding
	return r
}
func (r ApiGetTimeSeriesDataRequest) Limit(limit int64) ApiGetTimeSeriesDataRequest {
	r.P_limit = &limit
	return r
}
func (r ApiGetTimeSeriesDataRequest) Offset(offset int64) ApiGetTimeSeriesDataRequest {
	r.P_offset = &offset
	return r
}
func (r ApiGetTimeSeriesDataRequest) Ascending(ascending bool) ApiGetTimeSeriesDataRequest {
	r.P_ascending = &ascending
	return r
}

func (r ApiGetTimeSeriesDataRequest) Execute() (MultipleSeriesDataLocationUnix, *_nethttp.Response, error) {
	return r.ApiService.GetTimeSeriesDataExecute(r)
}

/*
 * GetTimeSeriesData Method for GetTimeSeriesData
 * シリーズID、時刻を指定してサムネイル画像を取得する。

Supported application type:Web, Native, Client
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param collectionId コレクション名
 * @param seriesId シリーズID
 * @return ApiGetTimeSeriesDataRequest
 */
func (a *CollectionApiService) GetTimeSeriesData(Ctx _context.Context, collectionId string, seriesId string) ApiGetTimeSeriesDataRequest {
	return ApiGetTimeSeriesDataRequest{
		ApiService: a,
		Ctx: Ctx,
		P_collectionId: collectionId,
		P_seriesId: seriesId,
	}
}

/*
 * Execute executes the request
 * @return MultipleSeriesDataLocationUnix
 */
func (a *CollectionApiService) GetTimeSeriesDataExecute(r ApiGetTimeSeriesDataRequest) (MultipleSeriesDataLocationUnix, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MultipleSeriesDataLocationUnix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "CollectionApiService.GetTimeSeriesData")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/collections/{collection_id}/series/{series_id}/data"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", _neturl.PathEscape(parameterToString(r.P_collectionId, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"series_id"+"}", _neturl.PathEscape(parameterToString(r.P_seriesId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_timeRange == nil {
		return localVarReturnValue, nil, reportError("timeRange is required and must be specified")
	}

	if r.P_resourceOwnerId != nil {
		localVarQueryParams.Add("resource_owner_id", parameterToString(*r.P_resourceOwnerId, ""))
	}
	localVarQueryParams.Add("time_range", parameterToString(*r.P_timeRange, ""))
	if r.P_limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.P_limit, ""))
	}
	if r.P_offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.P_offset, ""))
	}
	if r.P_ascending != nil {
		localVarQueryParams.Add("ascending", parameterToString(*r.P_ascending, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.P_acceptEncoding != nil {
		localVarHeaderParams["Accept-Encoding"] = parameterToString(*r.P_acceptEncoding, "")
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCollectionArchiveRequest struct {
	Ctx _context.Context
	ApiService *CollectionApiService
	P_collectionId string
	P_resourceOwnerId *string
}

func (r ApiPostCollectionArchiveRequest) ResourceOwnerId(resourceOwnerId string) ApiPostCollectionArchiveRequest {
	r.P_resourceOwnerId = &resourceOwnerId
	return r
}

func (r ApiPostCollectionArchiveRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PostCollectionArchiveExecute(r)
}

/*
 * PostCollectionArchive Method for PostCollectionArchive
 * 指定した現場の時系列データをアーカイブし、アーカイブ・リストア状態をARCHIVEDにする。

Supported application type：Web, Native
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param collectionId コレクション名
 * @return ApiPostCollectionArchiveRequest
 */
func (a *CollectionApiService) PostCollectionArchive(Ctx _context.Context, collectionId string) ApiPostCollectionArchiveRequest {
	return ApiPostCollectionArchiveRequest{
		ApiService: a,
		Ctx: Ctx,
		P_collectionId: collectionId,
	}
}

/*
 * Execute executes the request
 */
func (a *CollectionApiService) PostCollectionArchiveExecute(r ApiPostCollectionArchiveRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "CollectionApiService.PostCollectionArchive")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/collections/{collection_id}/archive"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", _neturl.PathEscape(parameterToString(r.P_collectionId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.P_resourceOwnerId != nil {
		localVarQueryParams.Add("resource_owner_id", parameterToString(*r.P_resourceOwnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCollectionRestoreRequest struct {
	Ctx _context.Context
	ApiService *CollectionApiService
	P_collectionId string
	P_resourceOwnerId *string
}

func (r ApiPostCollectionRestoreRequest) ResourceOwnerId(resourceOwnerId string) ApiPostCollectionRestoreRequest {
	r.P_resourceOwnerId = &resourceOwnerId
	return r
}

func (r ApiPostCollectionRestoreRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PostCollectionRestoreExecute(r)
}

/*
 * PostCollectionRestore Method for PostCollectionRestore
 * 指定した現場の時系列データをリストアし、アーカイブ・リストア状態をREADYにする。

Supported application type：Web, Native
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param collectionId コレクション名
 * @return ApiPostCollectionRestoreRequest
 */
func (a *CollectionApiService) PostCollectionRestore(Ctx _context.Context, collectionId string) ApiPostCollectionRestoreRequest {
	return ApiPostCollectionRestoreRequest{
		ApiService: a,
		Ctx: Ctx,
		P_collectionId: collectionId,
	}
}

/*
 * Execute executes the request
 */
func (a *CollectionApiService) PostCollectionRestoreExecute(r ApiPostCollectionRestoreRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "CollectionApiService.PostCollectionRestore")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/collections/{collection_id}/restore"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", _neturl.PathEscape(parameterToString(r.P_collectionId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.P_resourceOwnerId != nil {
		localVarQueryParams.Add("resource_owner_id", parameterToString(*r.P_resourceOwnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostSearchLatestRequest struct {
	Ctx _context.Context
	ApiService *CollectionApiService
	P_collectionId string
	P_collectionLatestRequest *CollectionLatestRequest
	P_resourceOwnerId *string
	P_limit *int64
	P_offset *int64
	P_projection *string
	P_acceptEncoding *string
}

func (r ApiPostSearchLatestRequest) CollectionLatestRequest(collectionLatestRequest CollectionLatestRequest) ApiPostSearchLatestRequest {
	r.P_collectionLatestRequest = &collectionLatestRequest
	return r
}
func (r ApiPostSearchLatestRequest) ResourceOwnerId(resourceOwnerId string) ApiPostSearchLatestRequest {
	r.P_resourceOwnerId = &resourceOwnerId
	return r
}
func (r ApiPostSearchLatestRequest) Limit(limit int64) ApiPostSearchLatestRequest {
	r.P_limit = &limit
	return r
}
func (r ApiPostSearchLatestRequest) Offset(offset int64) ApiPostSearchLatestRequest {
	r.P_offset = &offset
	return r
}
func (r ApiPostSearchLatestRequest) Projection(projection string) ApiPostSearchLatestRequest {
	r.P_projection = &projection
	return r
}
func (r ApiPostSearchLatestRequest) AcceptEncoding(acceptEncoding string) ApiPostSearchLatestRequest {
	r.P_acceptEncoding = &acceptEncoding
	return r
}

func (r ApiPostSearchLatestRequest) Execute() (MultipleCollectionLatest, *_nethttp.Response, error) {
	return r.ApiService.PostSearchLatestExecute(r)
}

/*
 * PostSearchLatest Method for PostSearchLatest
 * 最新データを取得する。<br>
取得対象データはtimestampが最も新しいデータではなく`最後に送信されたデータ`となる。 <br>
またbulk uploadされたデータは過去データの扱いの為この最新データ取得で取得されるデータには影響しない。 <br>
projection=dataの場合は時系列データ保存API、imageかthumbnailの場合は画像保存APIで最後に保存されたものが取得対象となる。

Supported application type:Web, Native, Client
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param collectionId コレクション名
 * @return ApiPostSearchLatestRequest
 */
func (a *CollectionApiService) PostSearchLatest(Ctx _context.Context, collectionId string) ApiPostSearchLatestRequest {
	return ApiPostSearchLatestRequest{
		ApiService: a,
		Ctx: Ctx,
		P_collectionId: collectionId,
	}
}

/*
 * Execute executes the request
 * @return MultipleCollectionLatest
 */
func (a *CollectionApiService) PostSearchLatestExecute(r ApiPostSearchLatestRequest) (MultipleCollectionLatest, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MultipleCollectionLatest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "CollectionApiService.PostSearchLatest")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/collections/{collection_id}/search-latest"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", _neturl.PathEscape(parameterToString(r.P_collectionId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_collectionLatestRequest == nil {
		return localVarReturnValue, nil, reportError("collectionLatestRequest is required and must be specified")
	}

	if r.P_resourceOwnerId != nil {
		localVarQueryParams.Add("resource_owner_id", parameterToString(*r.P_resourceOwnerId, ""))
	}
	if r.P_limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.P_limit, ""))
	}
	if r.P_offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.P_offset, ""))
	}
	if r.P_projection != nil {
		localVarQueryParams.Add("projection", parameterToString(*r.P_projection, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.P_acceptEncoding != nil {
		localVarHeaderParams["Accept-Encoding"] = parameterToString(*r.P_acceptEncoding, "")
	}
	// body params
	localVarPostBody = r.P_collectionLatestRequest
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSeriesRequest struct {
	Ctx _context.Context
	ApiService *CollectionApiService
	P_collectionId string
	P_seriesRequest *SeriesRequest
	P_resourceOwnerId *string
}

func (r ApiPostSeriesRequest) SeriesRequest(seriesRequest SeriesRequest) ApiPostSeriesRequest {
	r.P_seriesRequest = &seriesRequest
	return r
}
func (r ApiPostSeriesRequest) ResourceOwnerId(resourceOwnerId string) ApiPostSeriesRequest {
	r.P_resourceOwnerId = &resourceOwnerId
	return r
}

func (r ApiPostSeriesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PostSeriesExecute(r)
}

/*
 * PostSeries 時系列データ保存
 * データの保存、時系列データ存在確認への反映は非同期。

Supported application type: Web, Native, Client, Device
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param collectionId コレクション名
 * @return ApiPostSeriesRequest
 */
func (a *CollectionApiService) PostSeries(Ctx _context.Context, collectionId string) ApiPostSeriesRequest {
	return ApiPostSeriesRequest{
		ApiService: a,
		Ctx: Ctx,
		P_collectionId: collectionId,
	}
}

/*
 * Execute executes the request
 */
func (a *CollectionApiService) PostSeriesExecute(r ApiPostSeriesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "CollectionApiService.PostSeries")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/collections/{collection_id}/series"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", _neturl.PathEscape(parameterToString(r.P_collectionId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_seriesRequest == nil {
		return nil, reportError("seriesRequest is required and must be specified")
	}

	if r.P_resourceOwnerId != nil {
		localVarQueryParams.Add("resource_owner_id", parameterToString(*r.P_resourceOwnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_seriesRequest
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostSeriesBulkRequest struct {
	Ctx _context.Context
	ApiService *CollectionApiService
	P_collectionId string
	P_seriesBulkRequest *SeriesBulkRequest
	P_resourceOwnerId *string
}

func (r ApiPostSeriesBulkRequest) SeriesBulkRequest(seriesBulkRequest SeriesBulkRequest) ApiPostSeriesBulkRequest {
	r.P_seriesBulkRequest = &seriesBulkRequest
	return r
}
func (r ApiPostSeriesBulkRequest) ResourceOwnerId(resourceOwnerId string) ApiPostSeriesBulkRequest {
	r.P_resourceOwnerId = &resourceOwnerId
	return r
}

func (r ApiPostSeriesBulkRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PostSeriesBulkExecute(r)
}

/*
 * PostSeriesBulk Method for PostSeriesBulk
 * 複数のデータの保存、時系列データ存在確認への反映は非同期

Supported application type：Web, Native, Client, Device
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param collectionId コレクション名
 * @return ApiPostSeriesBulkRequest
 */
func (a *CollectionApiService) PostSeriesBulk(Ctx _context.Context, collectionId string) ApiPostSeriesBulkRequest {
	return ApiPostSeriesBulkRequest{
		ApiService: a,
		Ctx: Ctx,
		P_collectionId: collectionId,
	}
}

/*
 * Execute executes the request
 */
func (a *CollectionApiService) PostSeriesBulkExecute(r ApiPostSeriesBulkRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "CollectionApiService.PostSeriesBulk")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/collections/{collection_id}/series-bulk"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", _neturl.PathEscape(parameterToString(r.P_collectionId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_seriesBulkRequest == nil {
		return nil, reportError("seriesBulkRequest is required and must be specified")
	}

	if r.P_resourceOwnerId != nil {
		localVarQueryParams.Add("resource_owner_id", parameterToString(*r.P_resourceOwnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_seriesBulkRequest
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPutSeriesRequest struct {
	Ctx _context.Context
	ApiService *CollectionApiService
	P_collectionId string
	P_seriesId string
	P_timestamp int64
	P_seriesDataRequest *SeriesDataRequest
	P_resourceOwnerId *string
}

func (r ApiPutSeriesRequest) SeriesDataRequest(seriesDataRequest SeriesDataRequest) ApiPutSeriesRequest {
	r.P_seriesDataRequest = &seriesDataRequest
	return r
}
func (r ApiPutSeriesRequest) ResourceOwnerId(resourceOwnerId string) ApiPutSeriesRequest {
	r.P_resourceOwnerId = &resourceOwnerId
	return r
}

func (r ApiPutSeriesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PutSeriesExecute(r)
}

/*
 * PutSeries Method for PutSeries
 * データの保存、時系列データ存在確認への反映は非同期。

Supported application type: Web, Native, Client, Device
 * @param Ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param collectionId コレクション名
 * @param seriesId シリーズID
 * @param timestamp UNIXタイム(ミリ秒)
 * @return ApiPutSeriesRequest
 */
func (a *CollectionApiService) PutSeries(Ctx _context.Context, collectionId string, seriesId string, timestamp int64) ApiPutSeriesRequest {
	return ApiPutSeriesRequest{
		ApiService: a,
		Ctx: Ctx,
		P_collectionId: collectionId,
		P_seriesId: seriesId,
		P_timestamp: timestamp,
	}
}

/*
 * Execute executes the request
 */
func (a *CollectionApiService) PutSeriesExecute(r ApiPutSeriesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.Ctx, "CollectionApiService.PutSeries")
	if localBasePath == "/" {
	    localBasePath = ""
	}
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/collections/{collection_id}/series/{series_id}/timestamp/{timestamp}/data"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", _neturl.PathEscape(parameterToString(r.P_collectionId, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"series_id"+"}", _neturl.PathEscape(parameterToString(r.P_seriesId, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"timestamp"+"}", _neturl.PathEscape(parameterToString(r.P_timestamp, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.P_seriesDataRequest == nil {
		return nil, reportError("seriesDataRequest is required and must be specified")
	}

	if r.P_resourceOwnerId != nil {
		localVarQueryParams.Add("resource_owner_id", parameterToString(*r.P_resourceOwnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.P_seriesDataRequest
	req, err := a.client.prepareRequest(r.Ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
